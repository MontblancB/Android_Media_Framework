<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>미디어 보안 가이드 - Android Media Framework</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Archivo:wght@300;400;600;700;900&family=IBM+Plex+Mono:wght@400;500;600&family=Playfair+Display:wght@700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles/design-system.css">
</head>

<body>
    <nav class="nav">
        <a href="index.html" class="nav-button">← Android Media Framework</a>
    </nav>
    <div class="container">
        <header>
            <h1 class="page-title">미디어 보안 가이드</h1>
            <p class="page-subtitle">Android 미디어 프레임워크의 보안 모델과 DRM 통합</p>
        </header>

        <!-- Section 1: 개요 -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">01</span>미디어 보안 개요</h2>
            <p>미디어 보안은 <strong>콘텐츠 보호</strong>와 <strong>시스템 보안</strong> 두 가지 측면으로 나뉩니다. 프리미엄 콘텐츠의 불법 복제 방지와 동시에 악성 미디어 파일로부터 시스템을 보호해야 합니다.</p>

            <h3>1.1 보안 아키텍처</h3>
            <div class="mermaid">
flowchart TB
    subgraph REE["Rich Execution Environment (Android)"]
        APP[Media App]
        MC[MediaCodec]
        DRM[MediaDrm API]
    end

    subgraph TEE["Trusted Execution Environment"]
        OEM[OEMCrypto]
        SD[Secure Decoder]
        KS[Key Storage]
    end

    subgraph HW["Secure Hardware"]
        SB[Secure Buffer]
        HDCP[HDCP Output]
    end

    APP --> MC
    APP --> DRM
    DRM --> OEM
    MC --> SD
    OEM --> KS
    SD --> SB
    SB --> HDCP

            </div>
        </section>

        <!-- Section 2: 권한 모델 -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">02</span>미디어 권한 모델</h2>

            <h3>2.1 주요 미디어 권한</h3>
            <table>
                <thead>
                    <tr><th>권한</th><th>용도</th><th>보호 수준</th></tr>
                </thead>
                <tbody>
                    <tr><td><code>RECORD_AUDIO</code></td><td>마이크 접근</td><td>dangerous</td></tr>
                    <tr><td><code>CAMERA</code></td><td>카메라 접근</td><td>dangerous</td></tr>
                    <tr><td><code>READ_MEDIA_AUDIO</code></td><td>오디오 파일 읽기</td><td>dangerous</td></tr>
                    <tr><td><code>READ_MEDIA_VIDEO</code></td><td>비디오 파일 읽기</td><td>dangerous</td></tr>
                    <tr><td><code>MODIFY_AUDIO_SETTINGS</code></td><td>오디오 설정 변경</td><td>normal</td></tr>
                </tbody>
            </table>

            <h3>2.2 Scoped Storage (Android 10+)</h3>
            <pre><code>// MediaStore를 통한 안전한 미디어 접근
val collection = MediaStore.Video.Media.getContentUri(MediaStore.VOLUME_EXTERNAL)

val projection = arrayOf(
    MediaStore.Video.Media._ID,
    MediaStore.Video.Media.DISPLAY_NAME
)

contentResolver.query(collection, projection, null, null, null)?.use { cursor ->
    while (cursor.moveToNext()) {
        val id = cursor.getLong(0)
        val uri = ContentUris.withAppendedId(collection, id)
        // 안전하게 미디어 접근
    }
}</code></pre>
        </section>

        <!-- Section 3: Secure Buffer -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">03</span>Secure Buffer 처리</h2>

            <h3>3.1 Secure Buffer 흐름</h3>
            <div class="mermaid">
sequenceDiagram
    participant App
    participant MediaCodec
    participant TEE
    participant SecureMemory
    participant Display

    App->>MediaCodec: queueSecureInputBuffer()
    MediaCodec->>TEE: Decrypt in TEE
    TEE->>SecureMemory: Store decrypted frame
    Note over SecureMemory: Protected memory region
    SecureMemory->>Display: Direct render (HDCP)
    Note over Display: Never exposed to REE
            </div>

            <h3>3.2 Secure 코덱 설정</h3>
            <pre><code>// Secure 디코더 선택
val codecName = MediaCodecList(MediaCodecList.ALL_CODECS)
    .codecInfos
    .filter { !it.isEncoder }
    .filter { it.supportedTypes.contains("video/avc") }
    .firstOrNull {
        it.getCapabilitiesForType("video/avc")
            .isFeatureSupported(CodecCapabilities.FEATURE_SecurePlayback)
    }?.name

// Secure Surface 설정
val format = MediaFormat.createVideoFormat("video/avc", width, height)
mediaCodec.configure(format, secureSurface, mediaCrypto, 0)</code></pre>
        </section>

        <!-- Section 4: TEE 연동 -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">04</span>TEE (Trusted Execution Environment)</h2>

            <h3>4.1 TEE 구조</h3>
            <table>
                <thead>
                    <tr><th>구성요소</th><th>역할</th><th>위치</th></tr>
                </thead>
                <tbody>
                    <tr><td><strong>Trustlet</strong></td><td>TEE 내 실행 앱</td><td>Secure World</td></tr>
                    <tr><td><strong>OEMCrypto</strong></td><td>DRM 복호화</td><td>Secure World</td></tr>
                    <tr><td><strong>Keymaster</strong></td><td>키 관리</td><td>Secure World</td></tr>
                    <tr><td><strong>Secure Decoder</strong></td><td>보안 디코딩</td><td>Secure World</td></tr>
                </tbody>
            </table>

            <h3>4.2 OEMCrypto API</h3>
            <pre><code>// OEMCrypto 주요 함수 (Widevine L1)
OEMCrypto_Initialize()           // 초기화
OEMCrypto_OpenSession()          // 세션 열기
OEMCrypto_GenerateDerivedKeys()  // 키 유도
OEMCrypto_DecryptCENC()          // CENC 복호화
OEMCrypto_CloseSession()         // 세션 종료</code></pre>
        </section>

        <!-- Section 5: DRM 레벨 -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">05</span>DRM 보안 레벨</h2>

            <h3>5.1 Widevine 레벨 비교</h3>
            <table>
                <thead>
                    <tr><th>항목</th><th>L1</th><th>L2</th><th>L3</th></tr>
                </thead>
                <tbody>
                    <tr><td><strong>복호화</strong></td><td>TEE 내부</td><td>TEE 내부</td><td>소프트웨어</td></tr>
                    <tr><td><strong>디코딩</strong></td><td>TEE 내부</td><td>REE</td><td>REE</td></tr>
                    <tr><td><strong>최대 해상도</strong></td><td>4K HDR</td><td>SD/720p</td><td>SD</td></tr>
                    <tr><td><strong>하드웨어 요구</strong></td><td>TEE + Secure Path</td><td>TEE</td><td>없음</td></tr>
                    <tr><td><strong>인증 난이도</strong></td><td>높음</td><td>중간</td><td>낮음</td></tr>
                </tbody>
            </table>

            <h3>5.2 레벨 확인 코드</h3>
            <pre><code>val mediaDrm = MediaDrm(WIDEVINE_UUID)
val securityLevel = mediaDrm.getPropertyString("securityLevel")
// "L1", "L2", or "L3"

val hdcpLevel = mediaDrm.getPropertyString("hdcpLevel")
// "HDCP_V1", "HDCP_V2_2", etc.</code></pre>
        </section>

        <!-- Section 6: 보안 체크리스트 -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">06</span>보안 감사 체크리스트</h2>

            <h3>콘텐츠 보호</h3>
            <ul class="checklist">
                <li><input type="checkbox"> DRM 라이선스 서버 HTTPS 통신</li>
                <li><input type="checkbox"> Secure Buffer 사용 (L1 콘텐츠)</li>
                <li><input type="checkbox"> HDCP 출력 보호</li>
                <li><input type="checkbox"> 화면 캡처 방지 (FLAG_SECURE)</li>
            </ul>

            <h3>시스템 보안</h3>
            <ul class="checklist">
                <li><input type="checkbox"> 입력 파일 유효성 검증</li>
                <li><input type="checkbox"> 버퍼 오버플로우 방지</li>
                <li><input type="checkbox"> 권한 최소화 원칙</li>
                <li><input type="checkbox"> SELinux 정책 적용</li>
            </ul>
        </section>

        <!-- Section 7: 일반적인 미디어 보안 취약점 -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">07</span>일반적인 미디어 보안 취약점</h2>

            <h3>7.1 코덱 취약점 유형</h3>
            <table>
                <thead>
                    <tr><th>취약점 유형</th><th>설명</th><th>영향</th><th>대응</th></tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>버퍼 오버플로우</strong></td>
                        <td>잘못된 크기 계산으로 버퍼 초과 쓰기</td>
                        <td>코드 실행, 크래시</td>
                        <td>경계 검사, ASAN 테스트</td>
                    </tr>
                    <tr>
                        <td><strong>정수 오버플로우</strong></td>
                        <td>해상도/크기 계산 시 오버플로우</td>
                        <td>메모리 손상</td>
                        <td>SafeInt 라이브러리 사용</td>
                    </tr>
                    <tr>
                        <td><strong>힙 손상</strong></td>
                        <td>Use-after-free, Double-free</td>
                        <td>코드 실행</td>
                        <td>스마트 포인터, HWASAN</td>
                    </tr>
                    <tr>
                        <td><strong>포맷 문자열</strong></td>
                        <td>메타데이터의 포맷 문자열 주입</td>
                        <td>정보 유출, 크래시</td>
                        <td>포맷 문자열 고정</td>
                    </tr>
                </tbody>
            </table>

            <h3>7.2 주요 미디어 CVE 사례</h3>
            <div class="info-box warning">
                <strong>역사적인 미디어 취약점</strong>
                <ul>
                    <li><strong>Stagefright (2015)</strong>: MMS로 악성 MP4 전송 시 원격 코드 실행. MPEG4 파서의 정수 오버플로우.</li>
                    <li><strong>libstagefright (2016)</strong>: HEVC 파서 힙 오버플로우. 악성 동영상 재생 시 트리거.</li>
                    <li><strong>Mediaserver 취약점들</strong>: 다양한 컨테이너/코덱 파서의 메모리 안전성 문제.</li>
                </ul>
                <p><em>이러한 취약점들로 인해 Android 7.0부터 미디어 스택이 샌드박스화되고 프로세스 분리가 강화되었습니다.</em></p>
            </div>

            <h3>7.3 안전한 미디어 파일 처리</h3>
            <pre><code>// ❌ Bad: 직접 파일 접근
val inputStream = FileInputStream(untrustedFile)
mediaPlayer.setDataSource(inputStream.fd)

// ✅ Good: ContentResolver를 통한 안전한 접근
contentResolver.openFileDescriptor(uri, "r")?.use { pfd ->
    mediaPlayer.setDataSource(pfd.fileDescriptor)
}

// ✅ Good: 메타데이터 추출 시 타임아웃 및 예외 처리
fun safeExtractMetadata(uri: Uri): MediaMetadata? {
    return try {
        MediaMetadataRetriever().use { retriever ->
            retriever.setDataSource(context, uri)
            // 유효성 검증
            val duration = retriever.extractMetadata(
                MediaMetadataRetriever.METADATA_KEY_DURATION
            )?.toLongOrNull() ?: return null

            if (duration <= 0 || duration > MAX_DURATION_MS) {
                return null
            }
            // 안전하게 메타데이터 반환
            extractSafeMetadata(retriever)
        }
    } catch (e: Exception) {
        Log.w(TAG, "Failed to extract metadata", e)
        null
    }
}</code></pre>

            <h3>7.4 프로세스 분리 아키텍처 (Android 7.0+)</h3>
            <div class="mermaid">
flowchart TB
    subgraph APP["App Process"]
        A[Media App]
    end

    subgraph ISOLATED["Isolated Processes (Sandboxed)"]
        MC[mediacodec]
        ME[mediaextractor]
        MD[mediadrmserver]
    end

    subgraph SYSTEM["System Process"]
        MS[mediaserver]
        AF[audioflinger]
    end

    A -->|Binder IPC| MC
    A -->|Binder IPC| ME
    A -->|Binder IPC| MD
    MC --> MS
    MS --> AF
            </div>
            <p>미디어 코덱과 추출기가 별도 프로세스로 분리되어 취약점 악용 시 영향 범위가 제한됩니다.</p>
        </section>

        <!-- Section 8: DRM 시스템 비교 -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">08</span>DRM 시스템 비교</h2>

            <h3>8.1 주요 DRM 시스템</h3>
            <table>
                <thead>
                    <tr><th>DRM</th><th>소유사</th><th>주요 플랫폼</th><th>Android 지원</th></tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Widevine</strong></td>
                        <td>Google</td>
                        <td>Android, Chrome, Smart TV</td>
                        <td>네이티브 지원</td>
                    </tr>
                    <tr>
                        <td><strong>PlayReady</strong></td>
                        <td>Microsoft</td>
                        <td>Windows, Xbox, Smart TV</td>
                        <td>OEM 구현 필요</td>
                    </tr>
                    <tr>
                        <td><strong>FairPlay</strong></td>
                        <td>Apple</td>
                        <td>iOS, macOS, Apple TV</td>
                        <td>미지원</td>
                    </tr>
                    <tr>
                        <td><strong>ClearKey</strong></td>
                        <td>W3C (표준)</td>
                        <td>모든 EME 지원 브라우저</td>
                        <td>지원 (테스트용)</td>
                    </tr>
                </tbody>
            </table>

            <h3>8.2 Widevine vs PlayReady 상세 비교</h3>
            <table>
                <thead>
                    <tr><th>항목</th><th>Widevine</th><th>PlayReady</th></tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>라이선스 비용</strong></td>
                        <td>무료 (Google 기기)</td>
                        <td>유료 (로열티)</td>
                    </tr>
                    <tr>
                        <td><strong>보안 레벨</strong></td>
                        <td>L1, L2, L3</td>
                        <td>SL150, SL2000, SL3000</td>
                    </tr>
                    <tr>
                        <td><strong>TEE 요구</strong></td>
                        <td>L1: 필수</td>
                        <td>SL3000: 필수</td>
                    </tr>
                    <tr>
                        <td><strong>콘텐츠 제공자</strong></td>
                        <td>Netflix, YouTube, Amazon</td>
                        <td>Netflix, Amazon, Hulu</td>
                    </tr>
                    <tr>
                        <td><strong>Android 통합</strong></td>
                        <td>MediaDrm API 네이티브</td>
                        <td>별도 SDK 필요</td>
                    </tr>
                </tbody>
            </table>

            <h3>8.3 멀티 DRM 구현</h3>
            <pre><code>// 멀티 DRM 지원 (Widevine + PlayReady)
class MultiDrmManager(private val context: Context) {
    companion object {
        val WIDEVINE_UUID = UUID(-0x121074568629b532L, -0x5c37d8232ae2de13L)
        val PLAYREADY_UUID = UUID(-0x65fb0f8667bfbd7aL, -0x546d19a41f77a06bL)
    }

    fun getSupportedDrm(): DrmType {
        return when {
            MediaDrm.isCryptoSchemeSupported(WIDEVINE_UUID) -> DrmType.WIDEVINE
            MediaDrm.isCryptoSchemeSupported(PLAYREADY_UUID) -> DrmType.PLAYREADY
            else -> DrmType.CLEARKEY
        }
    }

    fun createDrmSession(drmType: DrmType, licenseUrl: String): DrmSession {
        val uuid = when (drmType) {
            DrmType.WIDEVINE -> WIDEVINE_UUID
            DrmType.PLAYREADY -> PLAYREADY_UUID
            DrmType.CLEARKEY -> CLEARKEY_UUID
        }

        val mediaDrm = MediaDrm(uuid)
        // 라이선스 서버 URL 설정
        mediaDrm.setPropertyString("serverUrl", licenseUrl)

        return DrmSession(mediaDrm)
    }
}

enum class DrmType { WIDEVINE, PLAYREADY, CLEARKEY }</code></pre>
        </section>

        <!-- Section 9: 콘텐츠 보호 우회 방지 -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">09</span>콘텐츠 보호 우회 방지</h2>

            <h3>9.1 화면 캡처/녹화 방지</h3>
            <pre><code>// Activity에서 화면 캡처 방지
class SecureVideoActivity : Activity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // FLAG_SECURE 설정 (스크린샷, 화면 녹화 방지)
        window.setFlags(
            WindowManager.LayoutParams.FLAG_SECURE,
            WindowManager.LayoutParams.FLAG_SECURE
        )
    }
}

// SurfaceView에서 Secure 플래그 설정
surfaceView.holder.addCallback(object : SurfaceHolder.Callback {
    override fun surfaceCreated(holder: SurfaceHolder) {
        // Secure Surface로 설정 (DRM 콘텐츠용)
        holder.surface.setFrameRate(60f, Surface.FRAME_RATE_COMPATIBILITY_DEFAULT)
    }
    // ...
})</code></pre>

            <h3>9.2 루팅/탈옥 기기 탐지</h3>
            <pre><code>object SecurityCheck {
    // 루팅 탐지 (기본적인 체크)
    fun isDeviceRooted(): Boolean {
        return checkRootBinaries() ||
               checkRootPackages() ||
               checkBuildTags() ||
               checkWritableSystem()
    }

    private fun checkRootBinaries(): Boolean {
        val paths = listOf(
            "/system/app/Superuser.apk",
            "/sbin/su", "/system/bin/su", "/system/xbin/su",
            "/data/local/xbin/su", "/data/local/bin/su",
            "/system/sd/xbin/su", "/system/bin/failsafe/su",
            "/data/local/su", "/su/bin/su"
        )
        return paths.any { File(it).exists() }
    }

    private fun checkRootPackages(): Boolean {
        val packages = listOf(
            "com.koushikdutta.superuser",
            "com.thirdparty.superuser",
            "eu.chainfire.supersu",
            "com.topjohnwu.magisk"
        )
        val pm = context.packageManager
        return packages.any { pkg ->
            try {
                pm.getPackageInfo(pkg, 0)
                true
            } catch (e: PackageManager.NameNotFoundException) {
                false
            }
        }
    }

    private fun checkBuildTags(): Boolean {
        val tags = Build.TAGS
        return tags != null && tags.contains("test-keys")
    }

    private fun checkWritableSystem(): Boolean {
        return try {
            Runtime.getRuntime().exec("mount").inputStream.bufferedReader()
                .readText().contains("/system.*rw")
        } catch (e: Exception) {
            false
        }
    }
}</code></pre>

            <h3>9.3 SafetyNet/Play Integrity API</h3>
            <pre><code>// Play Integrity API (SafetyNet 후속)
class IntegrityChecker(private val context: Context) {

    suspend fun checkIntegrity(): IntegrityResult {
        val integrityManager = IntegrityManagerFactory.create(context)

        // 무결성 토큰 요청
        val nonce = generateNonce()
        val request = IntegrityTokenRequest.builder()
            .setNonce(nonce)
            .build()

        return try {
            val response = integrityManager.requestIntegrityToken(request).await()
            val token = response.token()

            // 서버에서 토큰 검증 (권장)
            verifyTokenOnServer(token)
        } catch (e: Exception) {
            IntegrityResult.Error(e.message)
        }
    }

    private fun generateNonce(): String {
        val bytes = ByteArray(32)
        SecureRandom().nextBytes(bytes)
        return Base64.encodeToString(bytes, Base64.NO_WRAP)
    }
}

// DRM 재생 전 무결성 검사
suspend fun playDrmContent(uri: Uri) {
    val integrityResult = integrityChecker.checkIntegrity()

    when (integrityResult) {
        is IntegrityResult.Valid -> {
            // 정상 기기 → DRM 콘텐츠 재생
            startSecurePlayback(uri)
        }
        is IntegrityResult.DeviceTampered -> {
            // 루팅/변조 기기 → 저화질 또는 재생 거부
            showSecurityWarning()
        }
        is IntegrityResult.Error -> {
            // 네트워크 오류 등 → 오프라인 정책 적용
            applyOfflinePolicy(uri)
        }
    }
}</code></pre>

            <h3>9.4 HDCP 출력 보호</h3>
            <table>
                <thead>
                    <tr><th>HDCP 버전</th><th>지원 해상도</th><th>적용 콘텐츠</th></tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>HDCP 1.4</strong></td>
                        <td>1080p</td>
                        <td>HD 콘텐츠</td>
                    </tr>
                    <tr>
                        <td><strong>HDCP 2.2</strong></td>
                        <td>4K</td>
                        <td>4K/HDR 콘텐츠</td>
                    </tr>
                    <tr>
                        <td><strong>HDCP 2.3</strong></td>
                        <td>8K</td>
                        <td>8K/고급 HDR</td>
                    </tr>
                </tbody>
            </table>
            <pre><code>// HDCP 레벨 확인
val mediaDrm = MediaDrm(WIDEVINE_UUID)
val hdcpLevel = mediaDrm.connectedHdcpLevel

when (hdcpLevel) {
    MediaDrm.HDCP_LEVEL_UNKNOWN -> Log.d(TAG, "HDCP level unknown")
    MediaDrm.HDCP_NONE -> Log.d(TAG, "No HDCP")
    MediaDrm.HDCP_V1 -> Log.d(TAG, "HDCP 1.x - HD supported")
    MediaDrm.HDCP_V2 -> Log.d(TAG, "HDCP 2.0")
    MediaDrm.HDCP_V2_1 -> Log.d(TAG, "HDCP 2.1")
    MediaDrm.HDCP_V2_2 -> Log.d(TAG, "HDCP 2.2 - 4K supported")
    MediaDrm.HDCP_V2_3 -> Log.d(TAG, "HDCP 2.3 - 8K supported")
}

// 콘텐츠 해상도 정책 적용
val maxResolution = when {
    hdcpLevel >= MediaDrm.HDCP_V2_2 -> Resolution.UHD_4K
    hdcpLevel >= MediaDrm.HDCP_V1 -> Resolution.FHD_1080P
    else -> Resolution.SD_480P
}</code></pre>
        </section>

        <!-- 관련 문서 -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">10</span>관련 문서</h2>
            <ul>
                <li><a href="widevine.html">DRM & Widevine Architecture</a> - Widevine 상세</li>
                <li><a href="vendor-extension.html">Vendor Extension 개발</a> - HAL 보안</li>
                <li><a href="media-porting-checklist.html">포팅 체크리스트</a> - DRM 포팅</li>
                <li><a href="production-debugging.html">프로덕션 디버깅</a> - 보안 이슈 디버깅</li>
            </ul>
        </section>
    </div>

    <script src="scripts/mermaid-theme.js"></script>
    <script src="scripts/copy-code.js"></script>
    <script src="scripts/toc-generator.js"></script>
    <script src="scripts/page-navigation.js"></script>
    <script src="scripts/diagram-data.js"></script>
    <script src="scripts/diagram-interactive.js"></script>
    <script src="scripts/theme-toggle.js"></script>
    <script src="scripts/lang-switch.js"></script>
</body>
</html>
