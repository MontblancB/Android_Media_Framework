<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Prevent Flash of Incorrect Theme (FOIT) -->
    <script>
    (function(){var t=localStorage.getItem('android-media-framework-theme');if(t)document.documentElement.setAttribute('data-theme',t);else if(window.matchMedia&&window.matchMedia('(prefers-color-scheme:light)').matches)document.documentElement.setAttribute('data-theme','light');})();
    </script>
    <title>MediaProvider in Media Playback Flow</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Archivo:wght@300;400;600;700;900&family=IBM+Plex+Mono:wght@400;500;600&family=Playfair+Display:wght@700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles/design-system.css">

        <style>
        /* Page-specific styles loaded from design-system.css */
    </style>
</head>

<body>
    <nav class="nav">
        <a href="mediaprovider.html" class="nav-button">
            ← MediaProvider Overview
        </a>
    </nav>

    <div class="container">
        <header>
            <h1 class="page-title">🎬 미디어 재생 플로우</h1>
            <p class="page-subtitle">MediaProvider의 역할과 오디오/비디오 재생 과정</p>
        </header>

        <!-- Section 1: Overview -->
        <section class="content-section section">
            <h2 class="section-title">
                <span class="section-number">1</span>
                Overview: 미디어 재생에서 MediaProvider의 역할
            </h2>
            <p class="section-description">
                오디오/비디오 재생 시 MediaProvider는 미디어 파일 발견, 메타데이터 제공, 파일 접근 제어의 핵심 역할을 수행합니다.
            </p>

            <div class="content-grid">
                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🔍</span>
                        미디어 발견 및 인덱싱
                    </h3>
                    <div class="card-description">
                        <p><strong>MediaStore를 통한 미디어 검색</strong></p>
                        <ul>
                            <li>저장소 스캔 및 메타데이터 인덱싱</li>
                            <li><code>content://</code> URI로 미디어 식별</li>
                            <li>제목, 아티스트, 앨범, 재생 시간 등 메타데이터 제공</li>
                            <li>MIME 타입 자동 감지</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">📂</span>
                        파일 접근 제공
                    </h3>
                    <div class="card-description">
                        <p><strong>ContentResolver를 통한 데이터 접근</strong></p>
                        <ul>
                            <li><code>openFileDescriptor()</code>로 파일 디스크립터 제공</li>
                            <li><code>openInputStream()</code>으로 스트림 제공</li>
                            <li>Scoped Storage 권한 검사</li>
                            <li>FUSE를 통한 실시간 접근 제어</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🛡️</span>
                        보안 및 프라이버시
                    </h3>
                    <div class="card-description">
                        <p><strong>안전한 미디어 접근</strong></p>
                        <ul>
                            <li>앱별 권한 검사 (READ_MEDIA_*)</li>
                            <li>위치 정보 자동 제거 (Redaction)</li>
                            <li>다른 앱의 미디어 보호</li>
                            <li>FUSE Daemon을 통한 실시간 필터링</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">⚡</span>
                        성능 최적화
                    </h3>
                    <div class="card-description">
                        <p><strong>FUSE Passthrough (Android 12+)</strong></p>
                        <ul>
                            <li>권한 확인 후 직접 파일 시스템 접근</li>
                            <li>User-space 우회로 I/O 성능 향상</li>
                            <li>Random Read 성능 개선</li>
                            <li>네이티브 파일 시스템 수준의 속도</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 2: Complete Playback Flow -->
        <section class="content-section section">
            <h2 class="section-title">
                <span class="section-number">2</span>
                전체 재생 플로우
            </h2>
            <p class="section-description">
                앱이 미디어를 검색하고 재생하기까지의 전체 과정을 시각화합니다.
            </p>

            <div class="mermaid-container">
                <div class="mermaid">
                    sequenceDiagram
                    participant App as Media App
                    participant CR as ContentResolver
                    participant MP as MediaProvider
                    participant DB as SQLite DB
                    participant FUSE as FUSE Daemon
                    participant FS as File System
                    participant Player as MediaPlayer/Extractor

                    Note over App,Player: 1. 미디어 검색 단계
                    App->>CR: query(MediaStore.Audio.Media.EXTERNAL_CONTENT_URI)
                    CR->>MP: query() 호출
                    MP->>DB: SELECT * FROM audio WHERE...
                    DB-->>MP: Cursor (메타데이터)
                    MP-->>CR: Cursor 반환
                    CR-->>App: Cursor 반환
                    App->>App: Cursor 순회 및 URI 추출

                    Note over App,Player: 2. 파일 접근 단계
                    App->>CR: openFileDescriptor(content://media/...)
                    CR->>MP: openFile() 호출
                    MP->>MP: 권한 검사 (READ_MEDIA_AUDIO)
                    MP->>FUSE: FUSE_OPEN 요청
                    FUSE->>FUSE: 앱 UID 검증
                    FUSE->>FS: 실제 파일 열기
                    FS-->>FUSE: File Descriptor
                    FUSE->>FUSE: FUSE Passthrough 설정 (Android 12+)
                    FUSE-->>MP: FD 반환
                    MP-->>CR: ParcelFileDescriptor
                    CR-->>App: ParcelFileDescriptor

                    Note over App,Player: 3. 미디어 재생 단계
                    App->>Player: setDataSource(fileDescriptor)
                    Player->>Player: MediaExtractor 초기화
                    Player->>FS: read() - Passthrough 활성화 시 직접 접근
                    FS-->>Player: 미디어 데이터
                    Player->>Player: 디코딩 및 렌더링
                </div>
            </div>

            <div class="highlight-box">
                <strong>핵심 포인트:</strong>
                <ul>
                    <li><strong>1단계 (검색)</strong>: MediaProvider의 SQLite DB에서 메타데이터 쿼리</li>
                    <li><strong>2단계 (접근)</strong>: FUSE Daemon을 통한 권한 검사 및 파일 디스크립터 제공</li>
                    <li><strong>3단계 (재생)</strong>: MediaPlayer/MediaExtractor가 파일 디스크립터로 직접 읽기</li>
                    <li><strong>성능</strong>: FUSE Passthrough로 User-space 우회, 네이티브 속도 달성</li>
                </ul>
            </div>
        </section>

        <!-- Section 3: MediaPlayer Flow -->
        <section class="content-section section">
            <h2 class="section-title">
                <span class="section-number">3</span>
                MediaPlayer를 통한 재생
            </h2>
            <p class="section-description">
                고수준 API인 MediaPlayer를 사용한 간편한 미디어 재생 방식입니다.
            </p>

            <div class="mermaid-container">
                <div class="mermaid">
                    flowchart TD
                    START[앱 시작] --> QUERY[MediaStore 쿼리]
                    QUERY --> URI[content:// URI 획득]
                    URI --> MP_CREATE[MediaPlayer 생성]

                    MP_CREATE --> SET_DS{setDataSource 방식}

                    SET_DS -->|방법 1| URI_DS[setDataSource<br />context, uri]
                    SET_DS -->|방법 2| FD_DS[setDataSource<br />fileDescriptor]

                    URI_DS --> MP_INTERNAL[MediaPlayer 내부<br />ContentResolver 호출]
                    FD_DS --> SKIP[앱이 직접<br />FD 획득]

                    MP_INTERNAL --> OPEN_FD[openFileDescriptor]
                    SKIP --> OPEN_FD

                    OPEN_FD --> FUSE_CHECK[FUSE Daemon<br />권한 검사]
                    FUSE_CHECK --> PASSTHROUGH{FUSE Passthrough<br />가능?<br />Android 12+}

                    PASSTHROUGH -->|Yes| DIRECT[직접 파일<br />시스템 접근]
                    PASSTHROUGH -->|No| USERSPACE[User-space<br />경유 접근]

                    DIRECT --> PREPARE[prepare /<br />prepareAsync]
                    USERSPACE --> PREPARE

                    PREPARE --> START_PLAY[start]
                    START_PLAY --> DECODE[디코딩 및 재생]
                    DECODE --> END[재생 완료]

                </div>
            </div>

            <h3 style="color: var(--accent-primary); font-size: 1.5rem; margin-top: 40px; margin-bottom: 20px;">
                📝 MediaPlayer 사용 방식
            </h3>

            <div class="content-grid">
                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">1️⃣</span>
                        URI 방식 (권장)
                    </h3>
                    <div class="card-description">
                        <p><strong>가장 간단한 방법</strong></p>
                        <ul>
                            <li><code>setDataSource(context, uri)</code></li>
                            <li>MediaPlayer가 내부적으로 ContentResolver 호출</li>
                            <li>권한 처리 자동화</li>
                            <li>Scoped Storage 완벽 지원</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">2️⃣</span>
                        FileDescriptor 방식
                    </h3>
                    <div class="card-description">
                        <p><strong>세밀한 제어 가능</strong></p>
                        <ul>
                            <li>앱이 직접 <code>openFileDescriptor()</code> 호출</li>
                            <li><code>setDataSource(fileDescriptor)</code></li>
                            <li>오프셋 및 길이 지정 가능</li>
                            <li>여러 MediaPlayer 인스턴스에서 재사용</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">⚠️</span>
                        주의사항
                    </h3>
                    <div class="card-description">
                        <p><strong>파일 디스크립터 제약</strong></p>
                        <ul>
                            <li>Seekable FD 필요 (Pipe 불가)</li>
                            <li><code>ParcelFileDescriptor.createPipe()</code> 사용 불가</li>
                            <li>MediaPlayer는 Random Access 필요</li>
                            <li><code>openFileDescriptor()</code> 사용 권장</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🚀</span>
                        성능 고려사항
                    </h3>
                    <div class="card-description">
                        <p><strong>최적화 팁</strong></p>
                        <ul>
                            <li><code>prepareAsync()</code> 사용 (UI Thread 블로킹 방지)</li>
                            <li>FUSE Passthrough 활용 (Android 12+)</li>
                            <li>로컬 파일은 URI 방식이 효율적</li>
                            <li>스트리밍은 URL 방식 사용</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 4: MediaExtractor Flow -->
        <section class="content-section section">
            <h2 class="section-title">
                <span class="section-number">4</span>
                MediaExtractor를 통한 재생
            </h2>
            <p class="section-description">
                저수준 API인 MediaExtractor와 MediaCodec을 사용한 고급 미디어 처리 방식입니다.
            </p>

            <div class="mermaid-container">
                <div class="mermaid">
                    sequenceDiagram
                    participant App
                    participant CR as ContentResolver
                    participant MP as MediaProvider
                    participant FUSE as FUSE Daemon
                    participant FS as File System
                    participant ME as MediaExtractor
                    participant MC as MediaCodec

                    App->>CR: openFileDescriptor(uri)
                    CR->>MP: openFile()
                    MP->>FUSE: FUSE_OPEN
                    FUSE->>FS: 파일 열기
                    FS-->>FUSE: FD
                    FUSE->>FUSE: Passthrough 설정
                    FUSE-->>MP: FD
                    MP-->>CR: ParcelFileDescriptor
                    CR-->>App: ParcelFileDescriptor

                    App->>ME: setDataSource(fileDescriptor)
                    ME->>FS: 컨테이너 파싱 (MP4, MKV 등)
                    FS-->>ME: 트랙 정보
                    ME-->>App: Track Count 반환

                    App->>ME: selectTrack(trackIndex)
                    App->>MC: MediaCodec 생성 및 configure()
                    App->>MC: start()

                    loop 디코딩 루프
                    App->>ME: readSampleData(buffer)
                    ME->>FS: read() - Passthrough로 직접 접근
                    FS-->>ME: 인코딩된 샘플 데이터
                    ME-->>App: 샘플 데이터 반환

                    App->>MC: queueInputBuffer()
                    MC->>MC: 하드웨어 디코딩
                    MC-->>App: dequeueOutputBuffer()
                    App->>App: 렌더링 (AudioTrack/Surface)

                    App->>ME: advance()
                    end

                    App->>ME: release()
                    App->>MC: release()
                </div>
            </div>

            <h3 style="color: var(--accent-primary); font-size: 1.5rem; margin-top: 40px; margin-bottom: 20px;">
                🔧 MediaExtractor의 장점
            </h3>

            <div class="content-grid">
                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🎛️</span>
                        세밀한 제어
                    </h3>
                    <div class="card-description">
                        <p><strong>프레임 단위 처리</strong></p>
                        <ul>
                            <li>개별 샘플 데이터 접근</li>
                            <li>Presentation Timestamp 제어</li>
                            <li>특정 트랙 선택 (오디오/비디오/자막)</li>
                            <li>Seek 위치 정밀 제어</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🎨</span>
                        커스텀 처리
                    </h3>
                    <div class="card-description">
                        <p><strong>미디어 편집 및 변환</strong></p>
                        <ul>
                            <li>비디오 편집 (자르기, 병합)</li>
                            <li>포맷 변환 (Transcoding)</li>
                            <li>필터 적용 (색상 보정, 이펙트)</li>
                            <li>오디오 믹싱</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">📊</span>
                        메타데이터 추출
                    </h3>
                    <div class="card-description">
                        <p><strong>상세 정보 획득</strong></p>
                        <ul>
                            <li>코덱 정보 (MIME, Profile, Level)</li>
                            <li>해상도 및 프레임레이트</li>
                            <li>비트레이트 및 샘플레이트</li>
                            <li>재생 시간 및 트랙 수</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">⚡</span>
                        성능 최적화
                    </h3>
                    <div class="card-description">
                        <p><strong>효율적인 데이터 처리</strong></p>
                        <ul>
                            <li>Zero-Copy 버퍼 사용</li>
                            <li>하드웨어 가속 디코딩</li>
                            <li>FUSE Passthrough로 I/O 최적화</li>
                            <li>비동기 처리 가능</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 5: FUSE Passthrough Performance -->
        <section class="content-section section">
            <h2 class="section-title">
                <span class="section-number">5</span>
                FUSE Passthrough 성능 최적화
            </h2>
            <p class="section-description">
                Android 12+에서 도입된 FUSE Passthrough는 미디어 재생 성능을 획기적으로 개선합니다.
            </p>

            <div class="mermaid-container">
                <div class="mermaid">
                    flowchart TB
                    subgraph LEGACY ["Legacy FUSE - Android 11"]
                    direction TB
                    L_APP[App] --> L_KERNEL[Kernel FUSE]
                    L_KERNEL --> L_DAEMON[FUSE Daemon<br />User-space]
                    L_DAEMON --> L_KERNEL2[Kernel]
                    L_KERNEL2 --> L_FS[File System]
                    end

                    subgraph PASSTHROUGH ["FUSE Passthrough - Android 12+"]
                    direction TB
                    P_APP[App] --> P_KERNEL[Kernel FUSE]
                    P_KERNEL --> P_CHECK{권한 확인<br />최초 1회}
                    P_CHECK -->|허용| P_DIRECT[Direct Access<br />Kernel Only]
                    P_DIRECT --> P_FS[File System]
                    P_CHECK -.->|검사만| P_DAEMON[FUSE Daemon]
                    end

                    LEGACY -.->|성능 개선| PASSTHROUGH

                </div>
            </div>

            <h3 style="color: var(--accent-primary); font-size: 1.5rem; margin-top: 40px; margin-bottom: 20px;">
                📈 성능 비교
            </h3>

            <div class="content-grid">
                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🐌</span>
                        Legacy FUSE (Android 11)
                    </h3>
                    <div class="card-description">
                        <p><strong>User-space 경유</strong></p>
                        <ul>
                            <li>모든 read/write가 FUSE Daemon 경유</li>
                            <li>Kernel ↔ User-space 전환 오버헤드</li>
                            <li>Random Read 성능 저하</li>
                            <li>중저가 기기에서 성능 문제</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🚀</span>
                        FUSE Passthrough (Android 12+)
                    </h3>
                    <div class="card-description">
                        <p><strong>직접 파일 시스템 접근</strong></p>
                        <ul>
                            <li>최초 권한 확인 후 직접 접근</li>
                            <li>User-space 우회</li>
                            <li>네이티브 파일 시스템 수준 성능</li>
                            <li>미디어 재생 끊김 현상 해결</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">⚙️</span>
                        Passthrough 동작 방식
                    </h3>
                    <div class="card-description">
                        <p><strong>ioctl 기반 최적화</strong></p>
                        <ul>
                            <li><code>FUSE_DEV_IOC_PASSTHROUGH_OPEN</code> ioctl 사용</li>
                            <li>FUSE 파일 객체 ↔ 하위 파일 객체 직접 연결</li>
                            <li>Read/Write만 Passthrough (다른 작업은 Daemon 경유)</li>
                            <li>정책 기반 선택적 적용</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">📊</span>
                        성능 향상 수치
                    </h3>
                    <div class="card-description">
                        <p><strong>벤치마크 결과</strong></p>
                        <ul>
                            <li>Random Read: 약 2~3배 향상</li>
                            <li>Sequential Write: 약 1.5~2배 향상</li>
                            <li>4K 비디오 재생 끊김 현상 제거</li>
                            <li>저가 기기에서 특히 큰 효과</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="warning-box">
                <strong>⚠️ 추가 최적화 기법:</strong>
                <ul style="margin-top: 10px; padding-left: 20px;">
                    <li><strong>Splicing</strong>: 데이터 복사 최소화</li>
                    <li><strong>Write-back Cache</strong>: FUSE 쓰기 캐시 활용</li>
                    <li><strong>Permission Caching</strong>: 권한 검사 결과 캐싱으로 IPC 감소</li>
                    <li><strong>FUSE Bypass</strong>: <code>/Android/data</code>, <code>/Android/obb</code> 디렉토리는 FUSE
                        우회</li>
                </ul>
            </div>
        </section>

        <!-- Section 6: Best Practices -->
        <section class="content-section section">
            <h2 class="section-title">
                <span class="section-number">6</span>
                미디어 재생 Best Practices
            </h2>
            <p class="section-description">
                MediaProvider를 활용한 효율적인 미디어 재생을 위한 권장사항입니다.
            </p>

            <div class="content-grid">
                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">✅</span>
                        권장 사항
                    </h3>
                    <div class="card-description">
                        <ul>
                            <li><strong>URI 사용</strong>: <code>content://</code> URI로 미디어 접근</li>
                            <li><strong>MediaStore 활용</strong>: 파일 경로 대신 MediaStore API 사용</li>
                            <li><strong>비동기 처리</strong>: <code>prepareAsync()</code>로 UI Thread 보호</li>
                            <li><strong>권한 요청</strong>: <code>READ_MEDIA_*</code> 권한 명시적 요청</li>
                            <li><strong>리소스 해제</strong>: <code>release()</code>로 리소스 정리</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">❌</span>
                        피해야 할 사항
                    </h3>
                    <div class="card-description">
                        <ul>
                            <li><strong>직접 파일 경로</strong>: <code>/storage/emulated/0/...</code> 직접 접근 지양</li>
                            <li><strong>Pipe 사용</strong>: MediaPlayer에 Pipe FileDescriptor 전달 불가</li>
                            <li><strong>UI Thread 블로킹</strong>: <code>prepare()</code>대신 <code>prepareAsync()</code>
                            </li>
                            <li><strong>권한 미확인</strong>: 권한 없이 미디어 접근 시도</li>
                            <li><strong>리소스 누수</strong>: MediaPlayer/MediaExtractor 미해제</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🎯</span>
                        성능 최적화
                    </h3>
                    <div class="card-description">
                        <ul>
                            <li><strong>Android 12+ 타겟</strong>: FUSE Passthrough 활용</li>
                            <li><strong>로컬 파일</strong>: URI 방식이 가장 효율적</li>
                            <li><strong>스트리밍</strong>: HTTP URL 직접 사용</li>
                            <li><strong>대용량 파일</strong>: MediaExtractor로 청크 단위 처리</li>
                            <li><strong>캐싱</strong>: 자주 사용하는 메타데이터 캐싱</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🔒</span>
                        보안 고려사항
                    </h3>
                    <div class="card-description">
                        <ul>
                            <li><strong>Scoped Storage 준수</strong>: Android 10+ 정책 따르기</li>
                            <li><strong>최소 권한 원칙</strong>: 필요한 권한만 요청</li>
                            <li><strong>사용자 동의</strong>: 다른 앱 미디어 수정 시 동의 획득</li>
                            <li><strong>민감 정보 보호</strong>: 위치 정보 등 Redaction 인지</li>
                            <li><strong>안전한 URI</strong>: 신뢰할 수 있는 출처의 URI만 사용</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 7: NuPlayer Architecture -->
        <section class="content-section section">
            <h2 class="section-title">
                <span class="section-number">7</span>
                NuPlayer 아키텍처
            </h2>
            <p class="section-description">
                Android 5.0+에서 사용되는 핵심 미디어 재생 엔진인 NuPlayer의 내부 구조입니다.
            </p>

            <div class="mermaid-container">
                <div class="mermaid">
                    graph TB
                    subgraph APP["Application"]
                        MEDIAPLAYER["MediaPlayer API"]
                    end

                    subgraph NUPLAYER["NuPlayer Engine"]
                        NUPLAYER_MAIN["NuPlayer<br/>(Main Controller)"]

                        subgraph SOURCE["Source"]
                            GENERIC_SRC["GenericSource<br/>(Local File/FD)"]
                            HTTP_SRC["HTTPLiveSource<br/>(HLS Streaming)"]
                            RTSP_SRC["RTSPSource<br/>(RTSP Streaming)"]
                        end

                        subgraph DECODER["Decoder"]
                            VIDEO_DEC["DecoderPassThrough<br/>(Video Decoder)"]
                            AUDIO_DEC["DecoderPassThrough<br/>(Audio Decoder)"]
                        end

                        subgraph RENDERER["Renderer"]
                            VIDEO_REN["VideoRenderer<br/>(Surface)"]
                            AUDIO_REN["AudioRenderer<br/>(AudioSink)"]
                        end
                    end

                    subgraph CODEC["Codec Layer"]
                        MEDIACODEC["MediaCodec"]
                        CODEC2["Codec2"]
                    end

                    subgraph OUTPUT["Output"]
                        SURFACE["Surface<br/>(SurfaceFlinger)"]
                        AUDIOTRACK["AudioTrack<br/>(AudioFlinger)"]
                    end

                    MEDIAPLAYER --> NUPLAYER_MAIN
                    NUPLAYER_MAIN --> SOURCE
                    SOURCE --> DECODER
                    DECODER --> MEDIACODEC
                    DECODER --> CODEC2
                    MEDIACODEC --> RENDERER
                    CODEC2 --> RENDERER
                    VIDEO_REN --> SURFACE
                    AUDIO_REN --> AUDIOTRACK
                </div>
            </div>

            <h3 style="color: var(--accent-primary); font-size: 1.5rem; margin-top: 40px; margin-bottom: 20px;">
                🔧 NuPlayer 주요 컴포넌트
            </h3>

            <div class="content-grid">
                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🎬</span>
                        NuPlayer Main Controller
                    </h3>
                    <div class="card-description">
                        <p><strong>중앙 제어 로직</strong></p>
                        <ul>
                            <li>State Machine 관리 (Idle, Preparing, Started, Paused)</li>
                            <li>Source, Decoder, Renderer 간 메시지 조정</li>
                            <li>Seek, Pause, Resume 등 재생 제어</li>
                            <li>에러 처리 및 콜백</li>
                            <li><code>frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayer.cpp</code></li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">📦</span>
                        Source (GenericSource)
                    </h3>
                    <div class="card-description">
                        <p><strong>데이터 소스 관리</strong></p>
                        <ul>
                            <li>MediaExtractor를 통한 컨테이너 파싱</li>
                            <li>트랙 선택 (오디오/비디오/자막)</li>
                            <li>압축된 샘플 데이터 읽기</li>
                            <li>Seek 위치 제어</li>
                            <li>로컬 파일, FileDescriptor, content:// URI 지원</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">⚙️</span>
                        Decoder (DecoderPassThrough)
                    </h3>
                    <div class="card-description">
                        <p><strong>코덱 래퍼</strong></p>
                        <ul>
                            <li>MediaCodec 또는 Codec2 사용</li>
                            <li>입력 버퍼 큐잉 (압축 데이터)</li>
                            <li>출력 버퍼 디큐잉 (디코딩된 데이터)</li>
                            <li>포맷 변경 감지 (해상도, 채널 변경)</li>
                            <li>비동기 처리 및 콜백</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🖥️</span>
                        Renderer (Video/Audio)
                    </h3>
                    <div class="card-description">
                        <p><strong>출력 렌더링</strong></p>
                        <ul>
                            <li><strong>VideoRenderer</strong>: Surface에 프레임 렌더링</li>
                            <li><strong>AudioRenderer</strong>: AudioSink를 통해 오디오 출력</li>
                            <li>A/V 동기화 (PTS 기반)</li>
                            <li>버퍼링 및 지연 관리</li>
                            <li>Drop/Duplicate 프레임 처리</li>
                        </ul>
                    </div>
                </div>
            </div>

            <h3 style="color: var(--accent-primary); font-size: 1.5rem; margin-top: 40px; margin-bottom: 20px;">
                🔄 NuPlayer State Machine
            </h3>

            <div class="mermaid-container">
                <div class="mermaid">
                    stateDiagram-v2
                    [*] --> IDLE
                    IDLE --> PREPARING: setDataSource() + prepare()
                    PREPARING --> PREPARED: onPrepared()
                    PREPARED --> STARTED: start()
                    STARTED --> PAUSED: pause()
                    PAUSED --> STARTED: start()
                    STARTED --> STARTED: seekTo() (내부 처리)
                    PAUSED --> PREPARING: reset()
                    STARTED --> PREPARING: reset()
                    PREPARED --> IDLE: release()
                    PREPARING --> IDLE: release()
                    STARTED --> IDLE: release()
                    PAUSED --> IDLE: release()
                    IDLE --> [*]
                </div>
            </div>

            <div class="highlight-box" style="margin-top: 30px;">
                <strong>💡 NuPlayer vs AwesomePlayer</strong><br/>
                <ul style="margin-top: 10px; padding-left: 20px;">
                    <li><strong>AwesomePlayer</strong>: Android 4.x 이하에서 사용된 레거시 플레이어 (동기 방식, 제한적 기능)</li>
                    <li><strong>NuPlayer</strong>: Android 5.0+에서 도입된 현대적 플레이어 (비동기 방식, HLS/DASH 지원)</li>
                    <li><strong>차이점</strong>: NuPlayer는 완전히 비동기 메시지 기반 아키텍처로 재설계됨</li>
                    <li><strong>현재</strong>: AwesomePlayer는 완전히 제거되고 NuPlayer만 사용</li>
                </ul>
            </div>
        </section>

        <!-- Section 8: Buffer Management and Data Flow -->
        <section class="content-section section">
            <h2 class="section-title">
                <span class="section-number">8</span>
                버퍼 관리 및 데이터 플로우
            </h2>
            <p class="section-description">
                미디어 재생 시 버퍼가 어떻게 관리되고 데이터가 어떻게 흐르는지 상세히 설명합니다.
            </p>

            <h3 style="color: var(--accent-primary); font-size: 1.5rem; margin-top: 20px; margin-bottom: 20px;">
                📊 End-to-End 데이터 플로우
            </h3>

            <div class="mermaid-container">
                <div class="mermaid">
                    graph LR
                    subgraph STORAGE["Storage"]
                        FILE["MP4 File<br/>(Container)"]
                    end

                    subgraph EXTRACTOR["MediaExtractor"]
                        PARSER["Container Parser"]
                        DEMUX["Demuxer"]
                    end

                    subgraph CODEC["MediaCodec"]
                        INPUT_Q["Input Queue<br/>(Compressed)"]
                        DECODER["Decoder<br/>(HW/SW)"]
                        OUTPUT_Q["Output Queue<br/>(Raw)"]
                    end

                    subgraph RENDERER["Renderer"]
                        V_RENDER["Video Renderer"]
                        A_RENDER["Audio Renderer"]
                    end

                    subgraph OUTPUT["Output"]
                        SURFACE["Surface<br/>(YUV/RGB)"]
                        AUDIOSINK["AudioSink<br/>(PCM)"]
                    end

                    FILE -->|read()| PARSER
                    PARSER --> DEMUX
                    DEMUX -->|H.264 NAL| INPUT_Q
                    DEMUX -->|AAC Frame| INPUT_Q
                    INPUT_Q --> DECODER
                    DECODER --> OUTPUT_Q
                    OUTPUT_Q -->|YUV Buffer| V_RENDER
                    OUTPUT_Q -->|PCM Buffer| A_RENDER
                    V_RENDER --> SURFACE
                    A_RENDER --> AUDIOSINK
                </div>
            </div>

            <h3 style="color: var(--accent-primary); font-size: 1.5rem; margin-top: 40px; margin-bottom: 20px;">
                🎯 버퍼 큐 구조
            </h3>

            <div class="content-grid">
                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">📥</span>
                        Input Buffer Queue
                    </h3>
                    <div class="card-description">
                        <p><strong>압축된 데이터 입력</strong></p>
                        <ul>
                            <li><strong>용량</strong>: 일반적으로 4~16개 버퍼</li>
                            <li><strong>크기</strong>: 코덱별 상이 (H.264: ~1MB, AAC: ~8KB)</li>
                            <li><strong>데이터</strong>: 압축된 비디오/오디오 프레임</li>
                            <li><strong>메타데이터</strong>: PTS, Flags (KeyFrame, EOS)</li>
                            <li><strong>흐름</strong>: MediaExtractor → Input Queue → Decoder</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">📤</span>
                        Output Buffer Queue
                    </h3>
                    <div class="card-description">
                        <p><strong>디코딩된 데이터 출력</strong></p>
                        <ul>
                            <li><strong>용량</strong>: 일반적으로 4~16개 버퍼</li>
                            <li><strong>크기</strong>: 큼 (1920x1080 YUV: ~3MB, PCM: ~192KB)</li>
                            <li><strong>데이터</strong>: YUV 프레임 또는 PCM 오디오</li>
                            <li><strong>메타데이터</strong>: PTS, 색상 포맷</li>
                            <li><strong>흐름</strong>: Decoder → Output Queue → Renderer</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">⚡</span>
                        Zero-Copy 메커니즘
                    </h3>
                    <div class="card-description">
                        <p><strong>메모리 복사 최소화</strong></p>
                        <ul>
                            <li><strong>Shared Memory</strong>: 프로세스 간 버퍼 공유</li>
                            <li><strong>ION Allocator</strong>: 커널 레벨 메모리 할당</li>
                            <li><strong>Gralloc</strong>: 그래픽 버퍼 공유</li>
                            <li><strong>File Descriptor</strong>: 버퍼 핸들 전달</li>
                            <li><strong>성능</strong>: CPU 사용량 및 메모리 대역폭 절감</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🏊</span>
                        Buffer Pool
                    </h3>
                    <div class="card-description">
                        <p><strong>버퍼 재사용</strong></p>
                        <ul>
                            <li><strong>C2BlockPool</strong>: Codec2의 버퍼 풀</li>
                            <li><strong>할당 전략</strong>: 미리 할당하여 재사용</li>
                            <li><strong>메모리 효율</strong>: 할당/해제 오버헤드 제거</li>
                            <li><strong>참조 카운트</strong>: 사용 중인 버퍼 추적</li>
                            <li><strong>해제 시점</strong>: 참조 카운트 0일 때 풀로 반환</li>
                        </ul>
                    </div>
                </div>
            </div>

            <h3 style="color: var(--accent-primary); font-size: 1.5rem; margin-top: 40px; margin-bottom: 20px;">
                🔄 버퍼 라이프사이클
            </h3>

            <div class="mermaid-container">
                <div class="mermaid">
                    sequenceDiagram
                    participant Pool as Buffer Pool
                    participant Source as NuPlayer Source
                    participant Decoder as MediaCodec
                    participant Renderer as Renderer
                    participant Surface as Surface/AudioSink

                    Note over Pool: 버퍼 할당 단계
                    Pool->>Pool: 버퍼 사전 할당 (초기화)

                    Note over Source,Renderer: 재생 루프
                    loop 프레임마다 반복
                        Source->>Pool: 버퍼 요청
                        Pool-->>Source: 빈 버퍼 제공
                        Source->>Source: MediaExtractor로 데이터 읽기
                        Source->>Decoder: queueInputBuffer(압축 데이터)

                        Decoder->>Decoder: 하드웨어 디코딩

                        Decoder->>Pool: 출력 버퍼 요청
                        Pool-->>Decoder: 빈 버퍼 제공
                        Decoder-->>Renderer: dequeueOutputBuffer(디코딩 데이터)

                        Renderer->>Surface: 렌더링 (releaseOutputBuffer)
                        Surface-->>Pool: 버퍼 반환 (참조 카운트 감소)
                    end

                    Note over Pool: 종료 시
                    Pool->>Pool: 모든 버퍼 해제
                </div>
            </div>

            <div class="warning-box" style="margin-top: 30px;">
                <strong>⚠️ 버퍼 관리 주의사항</strong>
                <ul style="margin-top: 10px; padding-left: 20px;">
                    <li><strong>버퍼 부족</strong>: Input Queue가 비면 디코더 starving 발생 → 프레임 드롭</li>
                    <li><strong>버퍼 넘침</strong>: Output Queue가 가득 차면 디코더 블로킹 → 지연 증가</li>
                    <li><strong>메모리 누수</strong>: 버퍼를 release하지 않으면 메모리 누수 → 앱 크래시</li>
                    <li><strong>동기화 문제</strong>: 잘못된 PTS로 버퍼 전달 시 A/V sync 깨짐</li>
                </ul>
            </div>
        </section>

        <!-- Section 9: A/V Sync Mechanism -->
        <section class="content-section section">
            <h2 class="section-title">
                <span class="section-number">9</span>
                A/V 동기화 메커니즘
            </h2>
            <p class="section-description">
                오디오와 비디오를 정확하게 동기화하여 립싱크를 유지하는 방법입니다.
            </p>

            <div class="mermaid-container">
                <div class="mermaid">
                    graph TB
                    subgraph DECODER["Decoder"]
                        V_DEC["Video Decoder"]
                        A_DEC["Audio Decoder"]
                    end

                    subgraph TIMESTAMP["Timestamp"]
                        V_PTS["Video PTS<br/>(μs)"]
                        A_PTS["Audio PTS<br/>(μs)"]
                    end

                    subgraph SYNC["Sync Controller"]
                        MEDIASYNC["MediaClock<br/>(Master Clock)"]
                        COMPARE["PTS 비교"]
                    end

                    subgraph RENDERER["Renderer"]
                        V_REN["VideoRenderer"]
                        A_REN["AudioRenderer"]
                    end

                    subgraph ACTION["Action"]
                        DROP["Drop Frame<br/>(비디오 늦음)"]
                        DUPLICATE["Duplicate Frame<br/>(비디오 빠름)"]
                        NORMAL["Normal Render"]
                    end

                    V_DEC --> V_PTS
                    A_DEC --> A_PTS
                    V_PTS --> COMPARE
                    A_PTS --> MEDIASYNC
                    MEDIASYNC --> COMPARE
                    COMPARE --> DROP
                    COMPARE --> DUPLICATE
                    COMPARE --> NORMAL
                    DROP --> V_REN
                    DUPLICATE --> V_REN
                    NORMAL --> V_REN
                    A_PTS --> A_REN
                </div>
            </div>

            <h3 style="color: var(--accent-primary); font-size: 1.5rem; margin-top: 40px; margin-bottom: 20px;">
                ⏱️ PTS (Presentation Time Stamp)
            </h3>

            <div class="content-grid">
                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🎬</span>
                        PTS 개념
                    </h3>
                    <div class="card-description">
                        <p><strong>재생 시간 정보</strong></p>
                        <ul>
                            <li><strong>정의</strong>: 각 프레임/샘플이 재생되어야 할 시간 (마이크로초 단위)</li>
                            <li><strong>기준</strong>: 미디어 시작 시점부터의 경과 시간</li>
                            <li><strong>출처</strong>: 컨테이너에서 추출 (MP4, MKV 등)</li>
                            <li><strong>전달</strong>: MediaExtractor → Decoder → Renderer</li>
                            <li><strong>예시</strong>: 30fps 비디오의 2번째 프레임 PTS = 33,333μs</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🔊</span>
                        Audio as Master Clock
                    </h3>
                    <div class="card-description">
                        <p><strong>오디오 기준 동기화</strong></p>
                        <ul>
                            <li><strong>이유</strong>: 사람은 오디오 지연에 더 민감</li>
                            <li><strong>방식</strong>: AudioSink의 현재 재생 위치를 Master Clock으로 사용</li>
                            <li><strong>계산</strong>: getPosition()으로 실제 재생 시간 추적</li>
                            <li><strong>비디오 조정</strong>: 오디오 PTS에 맞춰 비디오 렌더링</li>
                            <li><strong>허용 오차</strong>: 일반적으로 ±50ms 이내</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🎯</span>
                        동기화 전략
                    </h3>
                    <div class="card-description">
                        <p><strong>PTS 차이 처리</strong></p>
                        <ul>
                            <li><strong>비디오 늦음 (Video PTS > Audio PTS + 50ms)</strong>:
                                <ul style="margin-top: 5px; padding-left: 20px;">
                                    <li>→ 프레임 드롭 (Drop Frame)</li>
                                    <li>→ 빠른 디코딩 (Fast Forward)</li>
                                </ul>
                            </li>
                            <li><strong>비디오 빠름 (Video PTS < Audio PTS - 50ms)</strong>:
                                <ul style="margin-top: 5px; padding-left: 20px;">
                                    <li>→ 프레임 중복 (Duplicate Frame)</li>
                                    <li>→ 렌더링 지연 (Delay Render)</li>
                                </ul>
                            </li>
                            <li><strong>정상 범위 (±50ms 이내)</strong>: 정상 렌더링</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">⚙️</span>
                        동기화 구현
                    </h3>
                    <div class="card-description">
                        <p><strong>NuPlayer에서의 동기화</strong></p>
                        <ul>
                            <li><strong>MediaClock</strong>: 재생 시간 추적 클래스</li>
                            <li><strong>VideoRenderer</strong>: onDrainVideoQueue()에서 PTS 비교</li>
                            <li><strong>AudioRenderer</strong>: AudioSink를 통해 실제 재생 위치 제공</li>
                            <li><strong>Latency 보정</strong>: 오디오 출력 지연 고려</li>
                            <li><strong>실시간 조정</strong>: 매 프레임마다 동기화 검사</li>
                        </ul>
                    </div>
                </div>
            </div>

            <h3 style="color: var(--accent-primary); font-size: 1.5rem; margin-top: 40px; margin-bottom: 20px;">
                🔧 동기화 문제 해결
            </h3>

            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>문제</th>
                        <th>원인</th>
                        <th>해결 방법</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>립싱크 어긋남</strong></td>
                        <td>잘못된 PTS, 디코더 지연</td>
                        <td>MediaExtractor PTS 확인, 하드웨어 디코더 사용</td>
                    </tr>
                    <tr>
                        <td><strong>오디오 먼저 들림</strong></td>
                        <td>비디오 디코딩 느림</td>
                        <td>프레임 드롭, 해상도 낮추기, 코덱 변경</td>
                    </tr>
                    <tr>
                        <td><strong>비디오 먼저 보임</strong></td>
                        <td>오디오 버퍼링 지연</td>
                        <td>AudioTrack 버퍼 크기 조정, 출력 레이턴시 확인</td>
                    </tr>
                    <tr>
                        <td><strong>재생 중 sync 깨짐</strong></td>
                        <td>CPU 부하, 버퍼 부족</td>
                        <td>백그라운드 작업 중단, 버퍼 큐 크기 증가</td>
                    </tr>
                    <tr>
                        <td><strong>Seek 후 sync 깨짐</strong></td>
                        <td>Keyframe seek 오류</td>
                        <td>SEEK_TO_CLOSEST_SYNC 플래그 사용</td>
                    </tr>
                </tbody>
            </table>

            <div class="highlight-box" style="margin-top: 30px;">
                <strong>💡 동기화 디버깅</strong>
                <ul style="margin-top: 10px; padding-left: 20px;">
                    <li><strong>logcat</strong>: <code>adb logcat -s NuPlayer NuPlayerRenderer</code></li>
                    <li><strong>PTS 로그</strong>: "video PTS", "audio PTS" 검색</li>
                    <li><strong>Drop/Duplicate</strong>: "drop", "late" 키워드 확인</li>
                    <li><strong>Systrace</strong>: MediaCodec, AudioTrack 타이밍 분석</li>
                </ul>
            </div>
        </section>

        <!-- Section 10: Streaming Pipeline -->
        <section class="content-section section">
            <h2 class="section-title">
                <span class="section-number">10</span>
                스트리밍 파이프라인
            </h2>
            <p class="section-description">
                HLS, DASH 등 적응형 스트리밍 프로토콜과 ExoPlayer 아키텍처를 설명합니다.
            </p>

            <h3 style="color: var(--accent-primary); font-size: 1.5rem; margin-top: 20px; margin-bottom: 20px;">
                🌐 적응형 스트리밍 프로토콜
            </h3>

            <div class="content-grid">
                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">📺</span>
                        HLS (HTTP Live Streaming)
                    </h3>
                    <div class="card-description">
                        <p><strong>Apple 개발, 범용 지원</strong></p>
                        <ul>
                            <li><strong>포맷</strong>: .m3u8 플레이리스트 + .ts 세그먼트</li>
                            <li><strong>세그먼트</strong>: 일반적으로 6~10초 길이</li>
                            <li><strong>코덱</strong>: H.264, HEVC / AAC, AC-3</li>
                            <li><strong>DRM</strong>: FairPlay (iOS), Widevine (Android)</li>
                            <li><strong>사용</strong>: Apple, YouTube, Twitch</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🎬</span>
                        DASH (Dynamic Adaptive Streaming over HTTP)
                    </h3>
                    <div class="card-description">
                        <p><strong>MPEG 표준, 유연한 구조</strong></p>
                        <ul>
                            <li><strong>포맷</strong>: .mpd 매니페스트 + .m4s 세그먼트</li>
                            <li><strong>세그먼트</strong>: 2~10초 (설정 가능)</li>
                            <li><strong>코덱</strong>: H.264, VP9, AV1 / AAC, Opus</li>
                            <li><strong>DRM</strong>: Widevine, PlayReady</li>
                            <li><strong>사용</strong>: Netflix, YouTube (일부)</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">📊</span>
                        적응형 비트레이트 (ABR)
                    </h3>
                    <div class="card-description">
                        <p><strong>네트워크 대역폭에 따른 품질 조정</strong></p>
                        <ul>
                            <li><strong>멀티 비트레이트</strong>: 동일 콘텐츠를 여러 해상도/비트레이트로 인코딩</li>
                            <li><strong>대역폭 측정</strong>: 다운로드 속도 실시간 측정</li>
                            <li><strong>품질 전환</strong>: 네트워크 상태에 따라 자동 전환
                                <ul style="margin-top: 5px; padding-left: 20px;">
                                    <li>빠름: 1080p (6Mbps)</li>
                                    <li>보통: 720p (3Mbps)</li>
                                    <li>느림: 480p (1Mbps)</li>
                                </ul>
                            </li>
                            <li><strong>버퍼링 최소화</strong>: 끊김 현상 방지</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🔄</span>
                        세그먼트 다운로드 전략
                    </h3>
                    <div class="card-description">
                        <ul>
                            <li><strong>초기 버퍼링</strong>: 3~5개 세그먼트 미리 다운로드</li>
                            <li><strong>진행 중</strong>: 1~2개 세그먼트 앞서 다운로드</li>
                            <li><strong>Seek</strong>: Keyframe 세그먼트부터 다시 다운로드</li>
                            <li><strong>캐싱</strong>: 다운로드한 세그먼트 디스크 저장</li>
                            <li><strong>Prefetch</strong>: 예상 재생 경로 미리 다운로드</li>
                        </ul>
                    </div>
                </div>
            </div>

            <h3 style="color: var(--accent-primary); font-size: 1.5rem; margin-top: 40px; margin-bottom: 20px;">
                🎮 ExoPlayer 아키텍처
            </h3>

            <div class="mermaid-container">
                <div class="mermaid">
                    graph TB
                    subgraph APP["Application"]
                        PLAYER_API["ExoPlayer API"]
                    end

                    subgraph EXOPLAYER["ExoPlayer Core"]
                        PLAYBACK_THREAD["Playback Thread"]

                        subgraph COMPONENTS["Components"]
                            MEDIA_SOURCE["MediaSource<br/>(HLS/DASH/Local)"]
                            TRACK_SELECTOR["TrackSelector<br/>(품질 선택)"]
                            LOAD_CONTROL["LoadControl<br/>(버퍼링 정책)"]
                        end

                        subgraph RENDERERS["Renderers"]
                            VIDEO_RENDERER["VideoRenderer"]
                            AUDIO_RENDERER["AudioRenderer"]
                            TEXT_RENDERER["TextRenderer"]
                        end
                    end

                    subgraph PLATFORM["Platform"]
                        MEDIACODEC["MediaCodec"]
                        AUDIOTRACK["AudioTrack"]
                        SURFACE["Surface"]
                    end

                    PLAYER_API --> PLAYBACK_THREAD
                    PLAYBACK_THREAD --> COMPONENTS
                    COMPONENTS --> RENDERERS
                    VIDEO_RENDERER --> MEDIACODEC
                    AUDIO_RENDERER --> MEDIACODEC
                    MEDIACODEC --> SURFACE
                    MEDIACODEC --> AUDIOTRACK
                </div>
            </div>

            <div class="content-grid" style="margin-top: 30px;">
                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">📦</span>
                        MediaSource
                    </h3>
                    <div class="card-description">
                        <p><strong>데이터 소스 추상화</strong></p>
                        <ul>
                            <li><strong>HlsMediaSource</strong>: HLS 스트리밍</li>
                            <li><strong>DashMediaSource</strong>: DASH 스트리밍</li>
                            <li><strong>ProgressiveMediaSource</strong>: 로컬 파일, HTTP 다운로드</li>
                            <li><strong>ConcatenatingMediaSource</strong>: 여러 소스 병합</li>
                            <li><strong>ClippingMediaSource</strong>: 일부 구간만 재생</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🎯</span>
                        TrackSelector
                    </h3>
                    <div class="card-description">
                        <p><strong>트랙 선택 로직</strong></p>
                        <ul>
                            <li><strong>DefaultTrackSelector</strong>: 자동 품질 선택</li>
                            <li><strong>해상도 선택</strong>: 화면 크기 및 대역폭 고려</li>
                            <li><strong>언어 선택</strong>: 사용자 선호 언어</li>
                            <li><strong>자막 선택</strong>: 자막 트랙 자동/수동 선택</li>
                            <li><strong>커스터마이징</strong>: 앱별 선택 정책 구현 가능</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">⚙️</span>
                        LoadControl
                    </h3>
                    <div class="card-description">
                        <p><strong>버퍼링 정책 제어</strong></p>
                        <ul>
                            <li><strong>minBufferMs</strong>: 최소 버퍼 (기본: 50초)</li>
                            <li><strong>maxBufferMs</strong>: 최대 버퍼 (기본: 50초)</li>
                            <li><strong>bufferForPlaybackMs</strong>: 재생 시작 버퍼 (기본: 2.5초)</li>
                            <li><strong>bufferForPlaybackAfterRebufferMs</strong>: 재버퍼링 후 (기본: 5초)</li>
                            <li><strong>커스텀 정책</strong>: 네트워크 상태에 따라 동적 조정</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🎨</span>
                        ExoPlayer 장점
                    </h3>
                    <div class="card-description">
                        <ul>
                            <li><strong>일관성</strong>: 모든 기기에서 동일한 동작</li>
                            <li><strong>최신 기능</strong>: Google Play 통해 독립 업데이트</li>
                            <li><strong>확장성</strong>: 커스텀 Renderer, Extractor 지원</li>
                            <li><strong>DRM 통합</strong>: Widevine, PlayReady 기본 지원</li>
                            <li><strong>디버깅</strong>: 상세한 로그 및 이벤트 리스너</li>
                            <li><strong>Media3</strong>: 최신 Jetpack 라이브러리로 진화</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="highlight-box" style="margin-top: 30px;">
                <strong>💡 ExoPlayer vs MediaPlayer</strong><br/>
                <ul style="margin-top: 10px; padding-left: 20px;">
                    <li><strong>MediaPlayer</strong>: 간단한 로컬 재생에 적합, OS 버전에 따라 동작 차이</li>
                    <li><strong>ExoPlayer (Media3)</strong>: 스트리밍 필수, 일관된 동작, 고급 기능 필요 시 권장</li>
                    <li><strong>권장</strong>: 새 앱은 Media3 ExoPlayer 사용</li>
                </ul>
            </div>
        </section>

        <!-- Section 11: Code Examples -->
        <section class="content-section section">
            <h2 class="section-title">
                <span class="section-number">11</span>
                실제 코드 예시
            </h2>
            <p class="section-description">
                MediaPlayer, MediaExtractor, ExoPlayer를 사용한 실제 재생 코드입니다.
            </p>

            <h3 style="color: var(--accent-primary); font-size: 1.5rem; margin-top: 20px; margin-bottom: 20px;">
                🎬 MediaPlayer 기본 재생
            </h3>

            <div class="content-grid">
                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">📱</span>
                        URI 방식 재생
                    </h3>
                    <div class="card-description">
                        <p><strong>content:// URI 사용</strong></p>
                        <pre style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; overflow-x: auto; font-size: 0.85rem; line-height: 1.5;"><code>// MediaStore에서 오디오 URI 획득
val uri = MediaStore.Audio.Media.EXTERNAL_CONTENT_URI
val projection = arrayOf(MediaStore.Audio.Media._ID)
val cursor = contentResolver.query(uri, projection, null, null, null)

cursor?.use {
    if (it.moveToFirst()) {
        val id = it.getLong(it.getColumnIndexOrThrow(MediaStore.Audio.Media._ID))
        val audioUri = ContentUris.withAppendedId(uri, id)

        // MediaPlayer 초기화
        val mediaPlayer = MediaPlayer().apply {
            setDataSource(applicationContext, audioUri)
            prepareAsync()
            setOnPreparedListener {
                start()  // 재생 시작
            }
            setOnCompletionListener {
                release()  // 리소스 해제
            }
        }
    }
}</code></pre>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">📂</span>
                        FileDescriptor 방식
                    </h3>
                    <div class="card-description">
                        <p><strong>직접 FD 획득</strong></p>
                        <pre style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; overflow-x: auto; font-size: 0.85rem; line-height: 1.5;"><code>// FileDescriptor 획득
val pfd = contentResolver.openFileDescriptor(audioUri, "r")

pfd?.use { parcelFd ->
    val mediaPlayer = MediaPlayer().apply {
        setDataSource(parcelFd.fileDescriptor)
        prepare()  // 동기 방식
        start()

        // Seek 예시
        seekTo(30000)  // 30초 위치로 이동

        // 상태 확인
        val duration = duration  // ms
        val position = currentPosition  // ms
    }
}</code></pre>
                    </div>
                </div>
            </div>

            <h3 style="color: var(--accent-primary); font-size: 1.5rem; margin-top: 40px; margin-bottom: 20px;">
                🔧 MediaExtractor + MediaCodec
            </h3>

            <div class="content-grid">
                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">📦</span>
                        MediaExtractor 초기화
                    </h3>
                    <div class="card-description">
                        <pre style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; overflow-x: auto; font-size: 0.85rem; line-height: 1.5;"><code>val extractor = MediaExtractor()
val pfd = contentResolver.openFileDescriptor(videoUri, "r")

pfd?.use {
    extractor.setDataSource(it.fileDescriptor)

    // 비디오 트랙 찾기
    var videoTrackIndex = -1
    for (i in 0 until extractor.trackCount) {
        val format = extractor.getTrackFormat(i)
        val mime = format.getString(MediaFormat.KEY_MIME)
        if (mime?.startsWith("video/") == true) {
            videoTrackIndex = i
            extractor.selectTrack(i)
            break
        }
    }

    val format = extractor.getTrackFormat(videoTrackIndex)
    val width = format.getInteger(MediaFormat.KEY_WIDTH)
    val height = format.getInteger(MediaFormat.KEY_HEIGHT)
    val duration = format.getLong(MediaFormat.KEY_DURATION)  // μs
}</code></pre>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">⚙️</span>
                        MediaCodec 디코딩 루프
                    </h3>
                    <div class="card-description">
                        <pre style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; overflow-x: auto; font-size: 0.85rem; line-height: 1.5;"><code>val decoder = MediaCodec.createDecoderByType("video/avc")
decoder.configure(format, surface, null, 0)
decoder.start()

val bufferInfo = MediaCodec.BufferInfo()
var isEOS = false

while (!isEOS) {
    // 입력 버퍼 처리
    val inputIndex = decoder.dequeueInputBuffer(10000)
    if (inputIndex >= 0) {
        val inputBuffer = decoder.getInputBuffer(inputIndex)!!
        val sampleSize = extractor.readSampleData(inputBuffer, 0)

        if (sampleSize < 0) {
            decoder.queueInputBuffer(inputIndex, 0, 0, 0,
                MediaCodec.BUFFER_FLAG_END_OF_STREAM)
            isEOS = true
        } else {
            val pts = extractor.sampleTime
            decoder.queueInputBuffer(inputIndex, 0, sampleSize, pts, 0)
            extractor.advance()
        }
    }

    // 출력 버퍼 처리
    val outputIndex = decoder.dequeueOutputBuffer(bufferInfo, 10000)
    if (outputIndex >= 0) {
        decoder.releaseOutputBuffer(outputIndex, true)  // Surface 렌더링
    }
}

decoder.stop()
decoder.release()
extractor.release()</code></pre>
                    </div>
                </div>
            </div>

            <h3 style="color: var(--accent-primary); font-size: 1.5rem; margin-top: 40px; margin-bottom: 20px;">
                🎮 ExoPlayer (Media3) 재생
            </h3>

            <div class="content-grid">
                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🌐</span>
                        HLS 스트리밍
                    </h3>
                    <div class="card-description">
                        <pre style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; overflow-x: auto; font-size: 0.85rem; line-height: 1.5;"><code>// build.gradle
implementation("androidx.media3:media3-exoplayer:1.2.0")
implementation("androidx.media3:media3-exoplayer-hls:1.2.0")
implementation("androidx.media3:media3-ui:1.2.0")

// ExoPlayer 초기화
val player = ExoPlayer.Builder(context)
    .setLoadControl(
        DefaultLoadControl.Builder()
            .setBufferDurationsMs(
                15000,  // minBufferMs
                50000,  // maxBufferMs
                2500,   // bufferForPlaybackMs
                5000    // bufferForPlaybackAfterRebufferMs
            )
            .build()
    )
    .build()

// HLS MediaSource
val hlsUrl = "https://example.com/playlist.m3u8"
val mediaItem = MediaItem.fromUri(hlsUrl)
player.setMediaItem(mediaItem)
player.prepare()
player.play()

// PlayerView에 연결
val playerView = findViewById<PlayerView>(R.id.player_view)
playerView.player = player</code></pre>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">📺</span>
                        로컬 파일 재생
                    </h3>
                    <div class="card-description">
                        <pre style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; overflow-x: auto; font-size: 0.85rem; line-height: 1.5;"><code>// content:// URI 사용
val mediaItem = MediaItem.fromUri(contentUri)

val player = ExoPlayer.Builder(context).build().apply {
    setMediaItem(mediaItem)

    // 이벤트 리스너
    addListener(object : Player.Listener {
        override fun onPlaybackStateChanged(state: Int) {
            when (state) {
                Player.STATE_BUFFERING -> Log.d(TAG, "Buffering...")
                Player.STATE_READY -> Log.d(TAG, "Ready to play")
                Player.STATE_ENDED -> Log.d(TAG, "Playback ended")
            }
        }

        override fun onPlayerError(error: PlaybackException) {
            Log.e(TAG, "Playback error: ${error.message}")
        }
    })

    prepare()
    play()
}

// Seek
player.seekTo(60000)  // 60초 위치

// 재생 속도 조절
player.setPlaybackSpeed(1.5f)  // 1.5배속

// 해제
player.release()</code></pre>
                    </div>
                </div>
            </div>

            <div class="warning-box" style="margin-top: 30px;">
                <strong>⚠️ 코드 사용 시 주의사항</strong>
                <ul style="margin-top: 10px; padding-left: 20px;">
                    <li><strong>권한</strong>: READ_MEDIA_AUDIO, READ_MEDIA_VIDEO 권한 필요 (Android 13+)</li>
                    <li><strong>UI Thread</strong>: prepareAsync() 또는 ExoPlayer 비동기 사용</li>
                    <li><strong>리소스 해제</strong>: 반드시 release() 호출 (메모리 누수 방지)</li>
                    <li><strong>생명주기</strong>: Activity/Fragment 생명주기에 맞춰 pause/resume</li>
                </ul>
            </div>
        </section>

        <!-- Section 12: Performance Profiling -->
        <section class="content-section section">
            <h2 class="section-title">
                <span class="section-number">12</span>
                성능 프로파일링 및 디버깅
            </h2>
            <p class="section-description">
                미디어 재생 성능을 측정하고 문제를 해결하는 방법입니다.
            </p>

            <h3 style="color: var(--accent-primary); font-size: 1.5rem; margin-top: 20px; margin-bottom: 20px;">
                🔍 디버깅 도구
            </h3>

            <div class="content-grid">
                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">📱</span>
                        adb logcat 필터링
                    </h3>
                    <div class="card-description">
                        <p><strong>미디어 재생 로그 추출</strong></p>
                        <pre style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; overflow-x: auto; font-size: 0.85rem; line-height: 1.5;"><code># NuPlayer 로그
adb logcat -s NuPlayer NuPlayerDriver NuPlayerRenderer

# MediaCodec 로그
adb logcat -s MediaCodec ACodec CCodec

# MediaExtractor 로그
adb logcat -s MediaExtractor MPEG4Extractor

# ExoPlayer 로그
adb logcat -s ExoPlayerImpl DefaultTrackSelector LoadControl

# A/V Sync 문제 디버깅
adb logcat | grep -iE "pts|sync|late|drop"

# 버퍼링 문제
adb logcat | grep -iE "buffer|starv|underrun"</code></pre>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">📊</span>
                        dumpsys 분석
                    </h3>
                    <div class="card-description">
                        <p><strong>시스템 상태 조회</strong></p>
                        <pre style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; overflow-x: auto; font-size: 0.85rem; line-height: 1.5;"><code># MediaPlayer 인스턴스 상태
adb shell dumpsys media.player

# MediaCodec 사용 현황
adb shell dumpsys media.codec

# AudioFlinger 상태
adb shell dumpsys media.audio_flinger

# 리소스 사용 현황
adb shell dumpsys media.resource_manager

# Surface 상태
adb shell dumpsys SurfaceFlinger</code></pre>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">📈</span>
                        Systrace 프로파일링
                    </h3>
                    <div class="card-description">
                        <p><strong>타이밍 분석</strong></p>
                        <pre style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; overflow-x: auto; font-size: 0.85rem; line-height: 1.5;"><code># Systrace 캡처 (10초)
adb shell atrace -z -t 10 \
  gfx input view webview wm am audio video camera hal \
  sched freq idle disk mmc load sync workq memreclaim \
  -o /data/local/tmp/trace.html

# PC로 복사
adb pull /data/local/tmp/trace.html

# Chrome에서 chrome://tracing 열어서 분석

# 주요 확인 사항:
# - MediaCodec 디코딩 시간
# - AudioTrack write 타이밍
# - SurfaceFlinger vsync
# - CPU 사용률 및 스케줄링</code></pre>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🎯</span>
                        ExoPlayer EventLogger
                    </h3>
                    <div class="card-description">
                        <p><strong>상세 이벤트 로깅</strong></p>
                        <pre style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; overflow-x: auto; font-size: 0.85rem; line-height: 1.5;"><code>// ExoPlayer에 EventLogger 추가
val player = ExoPlayer.Builder(context).build()
player.addAnalyticsListener(EventLogger())

// 로그 출력 내용:
// - 트랙 선택 (비디오/오디오 품질)
// - 버퍼링 이벤트 (시작/종료)
// - 디코더 초기화
// - 드롭된 프레임 수
// - 네트워크 대역폭 측정
// - 에러 및 경고</code></pre>
                    </div>
                </div>
            </div>

            <h3 style="color: var(--accent-primary); font-size: 1.5rem; margin-top: 40px; margin-bottom: 20px;">
                ⚠️ 일반적인 문제 및 해결책
            </h3>

            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>문제</th>
                        <th>원인</th>
                        <th>해결 방법</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>재생 시작 느림</strong></td>
                        <td>prepare() 동기 호출, 큰 파일</td>
                        <td>prepareAsync() 사용, 버퍼 크기 조정</td>
                    </tr>
                    <tr>
                        <td><strong>비디오 끊김 (버퍼링)</strong></td>
                        <td>네트워크 느림, 디코더 느림</td>
                        <td>LoadControl 버퍼 증가, 해상도 낮추기</td>
                    </tr>
                    <tr>
                        <td><strong>프레임 드롭</strong></td>
                        <td>CPU 부하, 디코더 성능 부족</td>
                        <td>하드웨어 디코더 사용, 백그라운드 작업 중단</td>
                    </tr>
                    <tr>
                        <td><strong>오디오 끊김</strong></td>
                        <td>AudioTrack 버퍼 부족, Underrun</td>
                        <td>AudioTrack 버퍼 크기 증가, 우선순위 상승</td>
                    </tr>
                    <tr>
                        <td><strong>Seek 느림</strong></td>
                        <td>Keyframe 멀리 위치, 인덱스 부재</td>
                        <td>SEEK_TO_CLOSEST_SYNC 플래그, 세그먼트 크기 조정</td>
                    </tr>
                    <tr>
                        <td><strong>메모리 부족</strong></td>
                        <td>리소스 미해제, 큰 버퍼</td>
                        <td>release() 호출, 버퍼 크기 감소, 해상도 낮추기</td>
                    </tr>
                    <tr>
                        <td><strong>DRM 재생 실패</strong></td>
                        <td>라이센스 만료, Secure Decoder 부재</td>
                        <td>라이센스 갱신, Widevine L1 지원 확인</td>
                    </tr>
                    <tr>
                        <td><strong>4K 재생 안됨</strong></td>
                        <td>하드웨어 미지원, 메모리 부족</td>
                        <td>media_codecs.xml 확인, 메모리 최적화</td>
                    </tr>
                </tbody>
            </table>

            <h3 style="color: var(--accent-primary); font-size: 1.5rem; margin-top: 40px; margin-bottom: 20px;">
                📊 성능 메트릭
            </h3>

            <div class="content-grid">
                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">⏱️</span>
                        재생 시작 시간 (Time to First Frame)
                    </h3>
                    <div class="card-description">
                        <ul>
                            <li><strong>목표</strong>: 1초 이내</li>
                            <li><strong>측정</strong>: setDataSource() ~ onPrepared()</li>
                            <li><strong>영향 요소</strong>: 네트워크 지연, 컨테이너 파싱, 디코더 초기화</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">📉</span>
                        드롭 프레임 비율
                    </h3>
                    <div class="card-description">
                        <ul>
                            <li><strong>목표</strong>: 1% 미만</li>
                            <li><strong>측정</strong>: dumpsys media.codec 또는 Systrace</li>
                            <li><strong>허용</strong>: Seek 직후 일시적 드롭은 정상</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🔄</span>
                        버퍼링 빈도
                    </h3>
                    <div class="card-description">
                        <ul>
                            <li><strong>목표</strong>: 5분당 1회 미만</li>
                            <li><strong>측정</strong>: ExoPlayer EventLogger</li>
                            <li><strong>개선</strong>: 초기 버퍼 증가, ABR 알고리즘 조정</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">💾</span>
                        메모리 사용량
                    </h3>
                    <div class="card-description">
                        <ul>
                            <li><strong>목표</strong>: 100MB 미만 (1080p 기준)</li>
                            <li><strong>측정</strong>: Android Profiler</li>
                            <li><strong>주의</strong>: 버퍼 크기와 해상도에 비례</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div class="highlight-box" style="margin-top: 30px;">
                <strong>💡 성능 최적화 팁</strong>
                <ul style="margin-top: 10px; padding-left: 20px;">
                    <li><strong>하드웨어 디코더 우선</strong>: 소프트웨어 디코더보다 10배 이상 효율적</li>
                    <li><strong>적절한 버퍼 크기</strong>: 너무 크면 메모리 낭비, 너무 작으면 버퍼링</li>
                    <li><strong>Surface 직접 렌더링</strong>: ByteBuffer 복사보다 빠름</li>
                    <li><strong>ExoPlayer 사용</strong>: MediaPlayer보다 안정적이고 기능 풍부</li>
                    <li><strong>FUSE Passthrough</strong>: Android 12+ 타겟으로 I/O 성능 향상</li>
                </ul>
            </div>
        </section>

        <!-- Section 13: AOSP Source Code Reference -->
        <section class="content-section section">
            <h2 class="section-title">
                <span class="section-number">13</span>
                AOSP 소스 코드 참조
            </h2>
            <p class="section-description">
                미디어 재생 파이프라인 관련 AOSP 소스 코드 위치 및 주요 파일입니다.
            </p>

            <h3 style="color: var(--accent-primary); font-size: 1.5rem; margin-top: 20px; margin-bottom: 20px;">
                📂 주요 디렉토리
            </h3>

            <div class="content-grid">
                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🎬</span>
                        NuPlayer
                    </h3>
                    <div class="card-description">
                        <ul style="font-size: 0.9rem; line-height: 1.6;">
                            <li><code>frameworks/av/media/libmediaplayerservice/nuplayer/</code><br/>
                            → NuPlayer.cpp (메인 컨트롤러)</li>
                            <li><code>NuPlayerSource.cpp</code><br/>
                            → Source 인터페이스</li>
                            <li><code>GenericSource.cpp</code><br/>
                            → 로컬 파일 소스</li>
                            <li><code>NuPlayerRenderer.cpp</code><br/>
                            → VideoRenderer, AudioRenderer</li>
                            <li><code>NuPlayerDecoder.cpp</code><br/>
                            → MediaCodec 래퍼</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">📦</span>
                        MediaExtractor
                    </h3>
                    <div class="card-description">
                        <ul style="font-size: 0.9rem; line-height: 1.6;">
                            <li><code>frameworks/av/media/libstagefright/</code><br/>
                            → MediaExtractor.cpp</li>
                            <li><code>MPEG4Extractor.cpp</code><br/>
                            → MP4/MOV 파서</li>
                            <li><code>MatroskaExtractor.cpp</code><br/>
                            → MKV/WebM 파서</li>
                            <li><code>frameworks/av/media/extractors/</code><br/>
                            → 각종 Extractor 플러그인</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">⚙️</span>
                        MediaCodec
                    </h3>
                    <div class="card-description">
                        <ul style="font-size: 0.9rem; line-height: 1.6;">
                            <li><code>frameworks/av/media/libstagefright/</code><br/>
                            → MediaCodec.cpp (API)</li>
                            <li><code>frameworks/av/media/codec2/</code><br/>
                            → Codec2 Framework</li>
                            <li><code>ACodec.cpp</code><br/>
                            → OpenMAX IL 래퍼 (레거시)</li>
                            <li><code>CCodec.cpp</code><br/>
                            → Codec2 래퍼</li>
                        </ul>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🔊</span>
                        Audio Output
                    </h3>
                    <div class="card-description">
                        <ul style="font-size: 0.9rem; line-height: 1.6;">
                            <li><code>frameworks/av/media/libaudioclient/</code><br/>
                            → AudioTrack.cpp</li>
                            <li><code>frameworks/av/services/audioflinger/</code><br/>
                            → AudioFlinger.cpp (믹싱)</li>
                            <li><code>Threads.cpp</code><br/>
                            → PlaybackThread</li>
                        </ul>
                    </div>
                </div>
            </div>

            <h3 style="color: var(--accent-primary); font-size: 1.5rem; margin-top: 40px; margin-bottom: 20px;">
                🔬 핵심 코드 예시
            </h3>

            <div class="content-grid">
                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🎯</span>
                        NuPlayer 상태 관리
                    </h3>
                    <div class="card-description">
                        <p><strong>NuPlayer.cpp</strong></p>
                        <pre style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; overflow-x: auto; font-size: 0.8rem; line-height: 1.5;"><code>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayer.cpp

void NuPlayer::onMessageReceived(const sp&lt;AMessage&gt; &msg) {
    switch (msg->what()) {
        case kWhatSetDataSource:
        {
            sp&lt;RefBase&gt; obj;
            CHECK(msg->findObject("source", &obj));
            mSource = static_cast&lt;Source *&gt;(obj.get());
            break;
        }

        case kWhatPrepare:
        {
            mSource->prepareAsync();
            postScanSources();
            break;
        }

        case kWhatStart:
        {
            mOffloadAudio = false;
            onStart();
            mPausedByClient = false;
            break;
        }

        // ... 기타 메시지 처리
    }
}</code></pre>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🔄</span>
                        A/V Sync 구현
                    </h3>
                    <div class="card-description">
                        <p><strong>NuPlayerRenderer.cpp</strong></p>
                        <pre style="background: rgba(0,0,0,0.3); padding: 15px; border-radius: 8px; overflow-x: auto; font-size: 0.8rem; line-height: 1.5;"><code>// frameworks/av/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp

void NuPlayerRenderer::onDrainVideoQueue() {
    VideoEntry entry = mVideoQueue.front();
    int64_t videoPTS = entry.mNotify->getInt64("timeUs");

    // 오디오 기준 시간 획득
    int64_t mediaTimeUs;
    int64_t nowUs = ALooper::GetNowUs();
    status_t result = getCurrentPosition(&mediaTimeUs);

    // PTS 차이 계산
    int64_t lateByUs = nowUs - videoPTS;

    if (lateByUs > 50000) {
        // 50ms 이상 늦음 → 프레임 드롭
        ALOGV("video late by %lld us, dropping frame", lateByUs);
        mVideoQueue.pop_front();
        notifyPendingBufferDrop();
        return;
    }

    // 정상 렌더링
    renderVideoFrame(entry);
}</code></pre>
                    </div>
                </div>
            </div>

            <div class="highlight-box" style="margin-top: 30px;">
                <strong>🔗 유용한 AOSP 링크</strong>
                <ul style="margin-top: 10px; padding-left: 20px;">
                    <li><strong>AOSP 소스 브라우저</strong>: <a href="https://cs.android.com/android/platform/superproject/+/master:frameworks/av/media/" target="_blank" style="color: var(--accent-primary);">cs.android.com (media)</a></li>
                    <li><strong>Media 공식 문서</strong>: <a href="https://source.android.com/docs/core/media" target="_blank" style="color: var(--accent-primary);">source.android.com/media</a></li>
                    <li><strong>MediaPlayer API</strong>: <a href="https://developer.android.com/reference/android/media/MediaPlayer" target="_blank" style="color: var(--accent-primary);">developer.android.com</a></li>
                    <li><strong>ExoPlayer 문서</strong>: <a href="https://developer.android.com/media/media3/exoplayer" target="_blank" style="color: var(--accent-primary);">Media3 ExoPlayer</a></li>
                </ul>
            </div>
        </section>

        <!-- Section 14: Related Pages -->
        <section class="content-section section">
            <h2 class="section-title">
                <span class="section-number">14</span>
                관련 상세 문서
            </h2>
            <p class="section-description">
                미디어 재생 파이프라인과 관련된 다른 주제들을 탐색하세요.
            </p>

            <div class="content-grid">
                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🏗️</span>
                        Media Framework Core
                    </h3>
                    <div class="card-description">
                        <p>전체 미디어 프레임워크 아키텍처</p>
                        <ul>
                            <li>AOSP 5-Layer 구조</li>
                            <li>Application → HAL 데이터 플로우</li>
                            <li>MediaPlayer/MediaCodec 위치</li>
                            <li>NuPlayer가 전체 구조에서 차지하는 역할</li>
                        </ul>
                        <a href="media-framework-core.html" style="display: inline-block; margin-top: 15px; padding: 10px 20px; background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(245, 158, 11, 0.2)); border: 1px solid #8b5cf6; border-radius: 8px; color: #a78bfa; text-decoration: none; font-weight: 600;">
                            자세히 보기 →
                        </a>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">⚙️</span>
                        Codec 2.0
                    </h3>
                    <div class="card-description">
                        <p>차세대 코덱 프레임워크</p>
                        <ul>
                            <li>C2Component 구조</li>
                            <li>Zero-Copy 버퍼 메커니즘</li>
                            <li>HAL 인터페이스 (HIDL/AIDL)</li>
                            <li>MediaCodec과의 통합</li>
                        </ul>
                        <a href="codec2.html" style="display: inline-block; margin-top: 15px; padding: 10px 20px; background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(245, 158, 11, 0.2)); border: 1px solid #8b5cf6; border-radius: 8px; color: #a78bfa; text-decoration: none; font-weight: 600;">
                            자세히 보기 →
                        </a>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">📦</span>
                        MediaExtractor
                    </h3>
                    <div class="card-description">
                        <p>컨테이너 파싱 및 디먹싱</p>
                        <ul>
                            <li>MP4/MKV/WebM 파싱</li>
                            <li>트랙 분리 및 메타데이터</li>
                            <li>NuPlayer GenericSource 통합</li>
                            <li>Extractor 플러그인 구조</li>
                        </ul>
                        <a href="media-extractor.html" style="display: inline-block; margin-top: 15px; padding: 10px 20px; background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(245, 158, 11, 0.2)); border: 1px solid #8b5cf6; border-radius: 8px; color: #a78bfa; text-decoration: none; font-weight: 600;">
                            자세히 보기 →
                        </a>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🔊</span>
                        Audio Framework
                    </h3>
                    <div class="card-description">
                        <p>오디오 처리 파이프라인</p>
                        <ul>
                            <li>AudioFlinger 믹싱 엔진</li>
                            <li>AudioTrack API</li>
                            <li>Audio HAL 인터페이스</li>
                            <li>NuPlayer AudioRenderer 통합</li>
                        </ul>
                        <a href="audio-framework.html" style="display: inline-block; margin-top: 15px; padding: 10px 20px; background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(245, 158, 11, 0.2)); border: 1px solid #8b5cf6; border-radius: 8px; color: #a78bfa; text-decoration: none; font-weight: 600;">
                            자세히 보기 →
                        </a>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🗄️</span>
                        MediaProvider
                    </h3>
                    <div class="card-description">
                        <p>미디어 파일 인덱싱 및 접근</p>
                        <ul>
                            <li>MediaStore API</li>
                            <li>FUSE Daemon 및 Passthrough</li>
                            <li>Scoped Storage 정책</li>
                            <li>재생 플로우에서의 역할</li>
                        </ul>
                        <a href="mediaprovider.html" style="display: inline-block; margin-top: 15px; padding: 10px 20px; background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(245, 158, 11, 0.2)); border: 1px solid #8b5cf6; border-radius: 8px; color: #a78bfa; text-decoration: none; font-weight: 600;">
                            자세히 보기 →
                        </a>
                    </div>
                </div>

                <div class="card">
                    <h3 class="card-title">
                        <span class="card-icon">🔐</span>
                        Widevine DRM
                    </h3>
                    <div class="card-description">
                        <p>DRM 보호 콘텐츠 재생</p>
                        <ul>
                            <li>Widevine L1/L2/L3</li>
                            <li>MediaDrm + MediaCodec 통합</li>
                            <li>Secure Decoder (TEE)</li>
                            <li>ExoPlayer DRM 지원</li>
                        </ul>
                        <a href="widevine.html" style="display: inline-block; margin-top: 15px; padding: 10px 20px; background: linear-gradient(135deg, rgba(139, 92, 246, 0.2), rgba(245, 158, 11, 0.2)); border: 1px solid #8b5cf6; border-radius: 8px; color: #a78bfa; text-decoration: none; font-weight: 600;">
                            자세히 보기 →
                        </a>
                    </div>
                </div>
            </div>
        </section>

        <!-- Footer -->
        <footer
            style="text-align: center; padding: 40px 20px; color: var(--text-muted); border-top: 1px solid var(--border-color); margin-top: 60px;">
            <p>Media Playback Pipeline & Data Flow</p>
            <p style="margin-top: 10px; font-size: 0.9rem;">
                Complete guide to Android media playback architecture
            </p>
            <p style="margin-top: 20px;">
                <a href="index.html" style="color: var(--accent-primary); text-decoration: none;">
                    ← AOSP Media Framework로 돌아가기
                </a>
            </p>
        </footer>
    </div>

    <script src="scripts/mermaid-theme.js"></script>
    <script>
        const observerOptions = {
            threshold: 0.1,
            rootMargin: '0px 0px -100px 0px'
        };

        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.style.opacity = '1';
                    entry.target.style.transform = 'translateY(0)';
                }
            });
        }, observerOptions);

        document.querySelectorAll('.section').forEach(section => {
            section.style.opacity = '0';
            section.style.transform = 'translateY(30px)';
            section.style.transition = 'opacity 0.6s ease-out, transform 0.6s ease-out';
            observer.observe(section);
        });
    </script>
    <!-- Navigation & Copy Features -->
    <script src="scripts/copy-code.js"></script>
    <script src="scripts/toc-generator.js"></script>
    <script src="scripts/page-navigation.js"></script>
    <!-- Interactive Diagram Features -->
    <script src="scripts/diagram-data.js"></script>
    <script src="scripts/diagram-interactive.js"></script>

    <script src="scripts/theme-toggle.js"></script>
    <script src="scripts/lang-switch.js"></script>
</body>

</html>