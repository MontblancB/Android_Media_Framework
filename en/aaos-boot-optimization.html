<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Prevent Flash of Incorrect Theme (FOIT) -->
    <script>
    (function(){var t=localStorage.getItem('android-media-framework-theme');if(t)document.documentElement.setAttribute('data-theme',t);else if(window.matchMedia&&window.matchMedia('(prefers-color-scheme:light)').matches)document.documentElement.setAttribute('data-theme','light');})();
    </script>
    <title>AAOS Boot & Media Optimization - Android Media Framework</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Archivo:wght@300;400;600;700;900&family=IBM+Plex+Mono:wght@400;500;600&family=Playfair+Display:wght@700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../styles/design-system.css">
</head>

<body>
    <nav class="nav">
        <a href="index.html" class="nav-button">&larr; Android Media Framework</a>
    </nav>
    <div class="container">
        <header>
            <h1 class="page-title">AAOS Boot & Media Optimization</h1>
            <p class="page-subtitle">Boot time reduction and media performance optimization for automotive environments</p>
        </header>

        <!-- Section 1: Overview -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">01</span>Vehicle Boot Requirements</h2>

            <p>Automotive IVI systems require <strong>fast boot</strong> and <strong>instant audio playback</strong>. Users expect radio or music to start playing as soon as they turn on the ignition.</p>

            <h3>1.1 Boot Time Targets</h3>
            <table>
                <thead>
                    <tr>
                        <th>Phase</th>
                        <th>Target Time</th>
                        <th>Description</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Cold Boot &rarr; Audio</strong></td>
                        <td>&lt; 3s</td>
                        <td>Power ON &rarr; First sound output</td>
                    </tr>
                    <tr>
                        <td><strong>Cold Boot &rarr; UI</strong></td>
                        <td>&lt; 5s</td>
                        <td>Power ON &rarr; Display visible</td>
                    </tr>
                    <tr>
                        <td><strong>Resume (Suspend)</strong></td>
                        <td>&lt; 1s</td>
                        <td>Sleep mode &rarr; Full operation</td>
                    </tr>
                    <tr>
                        <td><strong>Resume &rarr; Audio</strong></td>
                        <td>&lt; 500ms</td>
                        <td>Resume from sleep &rarr; Audio playback</td>
                    </tr>
                </tbody>
            </table>

            <h3>1.2 Boot Sequence</h3>
            <div class="mermaid">
flowchart LR
    subgraph BL["Bootloader<br/>(0.5s)"]
        A[U-Boot/ABL]
    end

    subgraph KN["Kernel<br/>(1.0s)"]
        B[Linux Kernel]
        C[Early Audio]
    end

    subgraph AN["Android<br/>(2.3s)"]
        D[Init/Zygote]
        E[System Server]
        F[CarService]
    end

    subgraph MD["Media<br/>(0.8s)"]
        G[AudioFlinger]
        H[MediaService]
        I((First Audio))
        J((App Ready))
    end

    A --> B
    A -.-> C
    B --> D
    C -.->|Handoff| G
    D --> E
    D --> G
    E --> F
    E --> H
    G --> I
    F --> J
            </div>
            <p class="diagram-caption">Total target time: under 5 seconds (First Audio: ~2s, App Ready: ~4s)</p>
        </section>

        <!-- Section 2: Boot Timeline Analysis -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">02</span>Boot Timeline Analysis</h2>

            <h3>2.1 Media Service Initialization Timeline</h3>
            <p>This shows the initialization timing of each media-related component during Cold Boot. Identifying the Critical Path (shortest path to First Audio) is key to optimization.</p>
            <div class="mermaid">
gantt
    title Cold Boot Media Service Timeline
    dateFormat X
    axisFormat %s

    section Bootloader
    U-Boot/ABL           :0, 500

    section Kernel
    Linux Kernel Init    :500, 1200
    ALSA Driver Load     :800, 1100
    Early Audio Start    :1100, 1300

    section Android Init
    init (1st stage)     :1200, 1500
    Zygote Preload       :1500, 2200
    System Server        :2200, 2800

    section Media Services
    AudioFlinger         :2300, 2600
    AudioPolicyService   :2600, 2800
    MediaCodecService    :2500, 2900
    MediaExtractorService:2600, 2800
    MediaDrmService      :2800, 3000
    Codec2 HAL Init      :2500, 3100

    section Car Services
    CarService           :2800, 3200
    CarAudioService      :3200, 3500
    CarMediaService      :3200, 3600

    section Milestones
    First Audio Output   :milestone, 2000, 0
    App Ready            :milestone, 4000, 0
            </div>

            <h3>2.2 Per-Service Initialization Times</h3>
            <table>
                <thead>
                    <tr>
                        <th>Service</th>
                        <th>Start Time</th>
                        <th>Duration</th>
                        <th>Critical Path</th>
                        <th>Notes</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>AudioFlinger</strong></td>
                        <td>~2.3s</td>
                        <td>~300ms</td>
                        <td>Yes</td>
                        <td>Audio HAL loading is the bottleneck</td>
                    </tr>
                    <tr>
                        <td><strong>AudioPolicyService</strong></td>
                        <td>~2.6s</td>
                        <td>~200ms</td>
                        <td>Yes</td>
                        <td>audio_policy.conf parsing</td>
                    </tr>
                    <tr>
                        <td><strong>MediaCodecService</strong></td>
                        <td>~2.5s</td>
                        <td>~400ms</td>
                        <td>No</td>
                        <td>media_codecs.xml parsing</td>
                    </tr>
                    <tr>
                        <td><strong>Codec2 HAL</strong></td>
                        <td>~2.5s</td>
                        <td>~600ms</td>
                        <td>No</td>
                        <td>Component store enumeration is the bottleneck</td>
                    </tr>
                    <tr>
                        <td><strong>CarAudioService</strong></td>
                        <td>~3.2s</td>
                        <td>~300ms</td>
                        <td>Yes</td>
                        <td>Audio zone configuration loading</td>
                    </tr>
                    <tr>
                        <td><strong>CarMediaService</strong></td>
                        <td>~3.2s</td>
                        <td>~400ms</td>
                        <td>Yes</td>
                        <td>Includes LMS restoration</td>
                    </tr>
                </tbody>
            </table>

            <h3>2.3 Critical Path Analysis</h3>
            <div class="mermaid">
flowchart LR
    A["Kernel Boot<br/>1.2s"] --> B["AudioFlinger<br/>300ms"]
    B --> C["AudioPolicyService<br/>200ms"]
    C --> D["CarAudioService<br/>300ms"]
    D --> E(("First Audio<br/>~2.0s"))

    A --> F["System Server<br/>600ms"]
    F --> G["CarService<br/>400ms"]
    G --> H["CarMediaService<br/>400ms"]
    H --> I(("App Ready<br/>~3.6s"))

    style E fill:#10b981,stroke:#059669,color:#fff
    style I fill:#3b82f6,stroke:#2563eb,color:#fff
            </div>
            <p class="diagram-caption">First Audio Critical Path: Kernel &rarr; AudioFlinger &rarr; AudioPolicyService &rarr; CarAudioService (~2.0s)</p>
        </section>

        <!-- Section 3: Cold Start Audio -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">03</span>Cold Start Audio Optimization</h2>

            <h3>3.1 Early Audio Architecture</h3>
            <div class="mermaid">
flowchart TB
    subgraph BOOT["Early Boot"]
        BL[Bootloader]
        KN[Kernel]
        EA[Early Audio Driver]
    end

    subgraph ANDROID["Android Boot"]
        AF[AudioFlinger]
        AP[AudioPolicyService]
        CAS[CarAudioService]
    end

    subgraph APP["Application"]
        MA[Media App]
        RA[Radio App]
    end

    BL --> KN
    KN --> EA
    EA -->|Handoff| AF
    AF --> AP
    AP --> CAS
    CAS --> MA
    CAS --> RA

            </div>

            <h3>3.2 Early Audio Implementation</h3>
            <pre><code>// Kernel Level Early Audio (drivers/audio/early_audio.c)

static int early_audio_init(void) {
    // Use audio config passed from bootloader
    struct early_audio_config *config = get_bootloader_audio_config();

    // Enable minimal audio path
    enable_audio_path(config->default_output);

    // Play boot sound or last radio frequency
    if (config->play_boot_sound) {
        play_cached_audio(BOOT_SOUND_PATH);
    } else if (config->last_radio_freq > 0) {
        tune_radio(config->last_radio_freq);
        unmute_radio();
    }

    return 0;
}

// Handoff to AudioFlinger after boot
static void handoff_to_audioflinger(void) {
    // Wait for AudioFlinger ready
    wait_for_audioflinger();

    // Transfer control
    transfer_audio_control();

    // Cleanup Early Audio driver
    early_audio_cleanup();
}</code></pre>

            <h3>3.3 Boot Sound Playback (Android Level)</h3>
            <pre><code>// BootCompletedReceiver.java
public class BootCompletedReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        if (Intent.ACTION_BOOT_COMPLETED.equals(intent.getAction())) {
            // Restore last media state
            restoreLastMediaState(context);
        }
    }

    private void restoreLastMediaState(Context context) {
        SharedPreferences prefs = context.getSharedPreferences(
            "media_state", Context.MODE_PRIVATE);

        String lastSource = prefs.getString("last_source", null);
        boolean wasPlaying = prefs.getBoolean("was_playing", false);

        if (lastSource != null) {
            // Restore last source via CarMediaService
            Car car = Car.createCar(context);
            CarMediaManager mediaManager = (CarMediaManager)
                car.getCarManager(Car.CAR_MEDIA_SERVICE);

            ComponentName source = ComponentName.unflattenFromString(lastSource);
            mediaManager.setMediaSource(source,
                CarMediaManager.MEDIA_SOURCE_MODE_PLAYBACK);

            if (wasPlaying) {
                // Auto-play
                mediaManager.getMediaController().getTransportControls().play();
            }
        }
    }
}</code></pre>
        </section>

        <!-- Section 4: Codec2 & Media Service Init Optimization -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">04</span>Codec2 & Media Service Init Optimization</h2>

            <p>The biggest bottleneck in media service initialization is <strong>Codec2 HAL component enumeration</strong>. The component store takes ~600ms to enumerate all codecs, and optimizing this can significantly reduce overall boot time.</p>

            <h3>4.1 init.rc Media Service Configuration</h3>
            <p>Boot priority for media-related services is controlled in <code>init.rc</code>. Services on the Critical Path should be set to <code>class core</code> for early startup.</p>
            <pre><code># device/&lt;vendor&gt;/&lt;product&gt;/init.&lt;product&gt;.rc

# Audio services - highest priority start (class core)
service audioserver /system/bin/audioserver
    class core
    user audioserver
    group audio camera drmrpc inet media mediadrm net_bt net_bt_admin
    capabilities BLOCK_SUSPEND
    ioprio rt 4
    task_profiles ProcessCapacityHigh HighPerformance
    onrestart restart vendor.audio-hal
    onrestart restart vendor.audio-hal-aidl

# Codec2 service - normal start (class main)
service vendor.media.c2@1.2-default /vendor/bin/hw/android.hardware.media.c2@1.2-service
    class main
    user mediacodec
    group camera drmrpc mediadrm
    ioprio rt 4
    task_profiles ProcessCapacityHigh

# MediaCodecService - can be changed to lazy loading
service mediacodec /system/bin/mediacodec
    class main
    user mediacodec
    group camera drmrpc mediadrm
    ioprio rt 4
    task_profiles ProcessCapacityHigh</code></pre>

            <h3>4.2 Codec2 Component Store Caching</h3>
            <p>Enumerating all codec components during Codec2 HAL initialization is the bottleneck. Results from previous boots can be cached and reused.</p>
            <pre><code>// vendor/&lt;vendor&gt;/codec2/C2VendorComponentStore.cpp

class C2VendorComponentStore : public C2ComponentStore {
public:
    c2_status_t listComponents() override {
        // 1. Try loading component list from cache
        if (loadCachedComponentList()) {
            ALOGI("Component list loaded from cache (%zu ms)",
                  elapsedMs());
            return C2_OK;  // ~50ms (cache hit)
        }

        // 2. On cache miss, perform full enumeration
        ALOGI("Cache miss, enumerating all components...");
        c2_status_t status = enumerateAllComponents();  // ~600ms

        // 3. Save results to cache
        if (status == C2_OK) {
            saveCachedComponentList();
        }
        return status;
    }

private:
    bool loadCachedComponentList() {
        std::string cachePath = "/data/vendor/media/codec2_cache.bin";

        // Validate cache (check HAL version, build ID)
        if (!isCacheValid(cachePath)) {
            return false;
        }

        // Load cached component list
        return deserializeComponentList(cachePath);
    }

    bool isCacheValid(const std::string& path) {
        // Invalidate cache if build fingerprint changed
        std::string currentFingerprint = android::base::GetProperty(
            "ro.build.fingerprint", "");
        std::string cachedFingerprint = readCacheFingerprint(path);
        return currentFingerprint == cachedFingerprint;
    }
};</code></pre>

            <h3>4.3 media_codecs.xml Optimization</h3>
            <p>Adjust the <strong>rank values</strong> in <code>media_codecs.xml</code> (parsed at boot) so that frequently used codecs are loaded first. Lower rank means higher priority.</p>
            <pre><code>&lt;!-- device/&lt;vendor&gt;/&lt;product&gt;/media_codecs.xml --&gt;
&lt;MediaCodecs&gt;
    &lt;!-- Lower rank = higher selection priority --&gt;

    &lt;!-- Most used audio codecs in vehicles: highest priority --&gt;
    &lt;MediaCodec name="c2.vendor.aac.decoder" type="audio/mp4a-latm"
               rank="1"&gt;
        &lt;Limit name="channel-count" max="8" /&gt;
        &lt;Limit name="sample-rate" ranges="7350-48000" /&gt;
    &lt;/MediaCodec&gt;

    &lt;MediaCodec name="c2.vendor.mp3.decoder" type="audio/mpeg"
               rank="1"&gt;
        &lt;Limit name="channel-count" max="2" /&gt;
        &lt;Limit name="sample-rate" ranges="8000-48000" /&gt;
    &lt;/MediaCodec&gt;

    &lt;!-- Video codecs: not needed at boot, assign high rank --&gt;
    &lt;MediaCodec name="c2.vendor.hevc.decoder" type="video/hevc"
               rank="100"&gt;
        &lt;Limit name="size" min="2x2" max="4096x2304" /&gt;
    &lt;/MediaCodec&gt;

    &lt;MediaCodec name="c2.vendor.avc.decoder" type="video/avc"
               rank="50"&gt;
        &lt;Limit name="size" min="2x2" max="4096x2304" /&gt;
    &lt;/MediaCodec&gt;
&lt;/MediaCodecs&gt;</code></pre>

            <h3>4.4 Parallel Media Service Initialization</h3>
            <p>By default, media-related HAL services start sequentially. Services without dependencies can be started in parallel to reduce boot time.</p>
            <div class="mermaid">
flowchart TB
    subgraph SEQ["Sequential Init (Default, ~1.8s)"]
        direction LR
        S1["AudioFlinger<br/>300ms"] --> S2["AudioPolicy<br/>200ms"]
        S2 --> S3["MediaCodec<br/>400ms"]
        S3 --> S4["Codec2 HAL<br/>600ms"]
        S4 --> S5["MediaDRM<br/>200ms"]
    end

    subgraph PAR["Parallel Init (Optimized, ~0.9s)"]
        direction LR
        P1["AudioFlinger<br/>300ms"] --> P2["AudioPolicy<br/>200ms"]
        P3["MediaCodec<br/>400ms"] --> P5["MediaDRM<br/>200ms"]
        P4["Codec2 HAL<br/>600ms"]
    end

    style SEQ fill:#1e293b,stroke:#ef4444,color:#f1f5f9
    style PAR fill:#1e293b,stroke:#10b981,color:#f1f5f9
            </div>
            <p class="diagram-caption">Only AudioFlinger &rarr; AudioPolicy requires sequential ordering. MediaCodec, Codec2, MediaDRM can run in parallel</p>

            <pre><code>// system/core/init/service_list.cpp
// init configuration for parallel media service startup

// Define parallel start groups in init.rc
// Use group_start to simultaneously start services without dependencies

# device/&lt;vendor&gt;/&lt;product&gt;/init.media.rc

on post-fs-data
    # Audio path must be sequential (dependency exists)
    start audioserver
    # Start AudioPolicy after audioserver is ready
    wait_for_prop init.svc.audioserver running
    start audiopolicy

on boot
    # Start remaining media services in parallel
    start mediacodec
    start vendor.media.c2
    start mediadrm</code></pre>
        </section>

        <!-- Section 5: Boot Time Reduction -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">05</span>Boot Time Reduction Techniques</h2>

            <h3>5.1 Media Service Optimization</h3>
            <table>
                <thead>
                    <tr>
                        <th>Optimization Technique</th>
                        <th>Effect</th>
                        <th>Target</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Lazy Loading</strong></td>
                        <td>-0.5s</td>
                        <td>Defer loading of unnecessary services</td>
                    </tr>
                    <tr>
                        <td><strong>Preload Cache</strong></td>
                        <td>-0.3s</td>
                        <td>Media metadata caching</td>
                    </tr>
                    <tr>
                        <td><strong>AOT Compilation</strong></td>
                        <td>-0.2s</td>
                        <td>Pre-compile media apps</td>
                    </tr>
                    <tr>
                        <td><strong>Parallel Init</strong></td>
                        <td>-0.4s</td>
                        <td>Parallel service initialization</td>
                    </tr>
                    <tr>
                        <td><strong>ReadAhead</strong></td>
                        <td>-0.2s</td>
                        <td>Filesystem prefetching</td>
                    </tr>
                </tbody>
            </table>

            <h3>5.2 CarService Boot Order Optimization</h3>
            <pre><code>&lt;!-- packages/services/Car/service/res/values/config.xml --&gt;
&lt;resources&gt;
    &lt;!-- Services to initialize first at boot --&gt;
    &lt;string-array name="config_earlyStartupServices"&gt;
        &lt;item&gt;com.android.car.audio.CarAudioService&lt;/item&gt;
        &lt;item&gt;com.android.car.media.CarMediaService&lt;/item&gt;
        &lt;item&gt;com.android.car.input.CarInputService&lt;/item&gt;
    &lt;/string-array&gt;

    &lt;!-- Services that can be deferred --&gt;
    &lt;string-array name="config_deferredServices"&gt;
        &lt;item&gt;com.android.car.telemetry.CarTelemetryService&lt;/item&gt;
        &lt;item&gt;com.android.car.watchdog.CarWatchdogService&lt;/item&gt;
    &lt;/string-array&gt;
&lt;/resources&gt;</code></pre>

            <h3>5.3 Media App Optimization</h3>
            <pre><code>// Media App Application class
class MediaApplication : Application() {
    override fun onCreate() {
        super.onCreate()

        // Perform heavy initialization in background
        Executors.newSingleThreadExecutor().execute {
            // Preload codecs
            preloadCodecs()

            // Cache media library
            cacheMediaLibrary()

            // Preload album arts
            preloadAlbumArts()
        }
    }

    private fun preloadCodecs() {
        // Pre-instantiate frequently used codecs
        val codecList = MediaCodecList(MediaCodecList.REGULAR_CODECS)
        codecList.codecInfos
            .filter { it.supportedTypes.contains("audio/mp4a-latm") }
            .take(2)
            .forEach { info ->
                try {
                    MediaCodec.createByCodecName(info.name).release()
                } catch (e: Exception) { }
            }
    }
}</code></pre>
        </section>

        <!-- Section 6: Resume Optimization -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">06</span>Suspend/Resume Optimization</h2>

            <h3>6.1 Suspend-to-RAM Flow</h3>
            <div class="mermaid">
sequenceDiagram
    participant Driver as Driver
    participant VHAL as Vehicle HAL
    participant CPS as CarPowerService
    participant CAS as CarAudioService
    participant AF as AudioFlinger

    Driver->>VHAL: Ignition OFF
    VHAL->>CPS: SHUTDOWN_PREPARE
    CPS->>CAS: prepareForSuspend()
    CAS->>CAS: saveAudioState()
    CAS->>AF: suspendOutput()

    Note over CPS: Suspend-to-RAM

    Driver->>VHAL: Ignition ON
    VHAL->>CPS: RESUME
    CPS->>CAS: resumeFromSuspend()
    CAS->>AF: resumeOutput()
    CAS->>CAS: restoreAudioState()
    AF-->>Driver: Audio Playing
            </div>

            <h3>6.2 Media State Save/Restore</h3>
            <pre><code>// Suspend handling in CarAudioService
class CarAudioService {
    private var savedState: MediaState? = null

    fun prepareForSuspend() {
        // Save current state
        savedState = MediaState(
            activeSource = currentMediaSource,
            playbackState = currentPlaybackState,
            position = currentPosition,
            volume = currentVolume,
            audioFocus = currentFocusHolder
        )

        // Stop audio output gracefully
        audioManager.abandonAudioFocus(currentFocusHolder)

        // Notify HAL that suspend preparation is complete
        notifyReadyForSuspend()
    }

    fun resumeFromSuspend() {
        savedState?.let { state ->
            // Restore volume
            setVolume(state.volume)

            // Restore media source
            setMediaSource(state.activeSource)

            // Restore playback position
            if (state.playbackState == PlaybackState.PLAYING) {
                seekTo(state.position)
                play()
            }
        }
    }
}</code></pre>

            <h3>6.3 Fast Resume Configuration</h3>
            <pre><code># System property settings
# Keep Audio HAL state active during suspend
persist.audio.keep_hal_active_on_suspend=true

# Prioritize audio path restore on resume
persist.car.audio.priority_restore=true

# Enable media state caching
persist.car.media.state_cache=true

# Minimize wake-up delay
persist.car.power.resume_delay_ms=100</code></pre>
        </section>

        <!-- Section 7: Memory Management -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">07</span>Memory Management in Constrained Environments</h2>

            <h3>7.1 Automotive Memory Constraints</h3>
            <table>
                <thead>
                    <tr>
                        <th>Category</th>
                        <th>Smartphone</th>
                        <th>Vehicle IVI</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Total RAM</strong></td>
                        <td>8-12GB</td>
                        <td>2-4GB</td>
                    </tr>
                    <tr>
                        <td><strong>Media App Allocation</strong></td>
                        <td>~512MB</td>
                        <td>~128MB</td>
                    </tr>
                    <tr>
                        <td><strong>Codec Buffers</strong></td>
                        <td>Flexible</td>
                        <td>Limited</td>
                    </tr>
                    <tr>
                        <td><strong>Cache Policy</strong></td>
                        <td>Aggressive</td>
                        <td>Conservative</td>
                    </tr>
                </tbody>
            </table>

            <h3>7.2 Memory Optimization Strategy</h3>
            <pre><code>// Media App Memory Management
class MediaService : Service() {
    private var thumbnailCache: LruCache&lt;String, Bitmap&gt;? = null

    override fun onCreate() {
        super.onCreate()

        // Determine cache size based on memory situation
        val maxMemory = (Runtime.getRuntime().maxMemory() / 1024).toInt()
        val cacheSize = maxMemory / 8  // 1/8 of max memory

        thumbnailCache = object : LruCache&lt;String, Bitmap&gt;(cacheSize) {
            override fun sizeOf(key: String, bitmap: Bitmap): Int {
                return bitmap.byteCount / 1024
            }
        }
    }

    override fun onTrimMemory(level: Int) {
        super.onTrimMemory(level)

        when (level) {
            TRIM_MEMORY_RUNNING_LOW -> {
                // Release 50% of cache
                thumbnailCache?.trimToSize(thumbnailCache!!.size() / 2)
            }
            TRIM_MEMORY_RUNNING_CRITICAL -> {
                // Release entire cache
                thumbnailCache?.evictAll()
                releaseUnusedCodecs()
            }
        }
    }

    private fun releaseUnusedCodecs() {
        // Release unused codec instances
        codecPool.values
            .filter { !it.isActive }
            .forEach { it.release() }
    }
}</code></pre>

            <h3>7.3 Low Memory Killer Configuration</h3>
            <pre><code>&lt;!-- frameworks/base/core/res/res/values/config.xml --&gt;
&lt;!-- Automotive LMK settings --&gt;
&lt;integer-array name="config_lowMemoryKillerOomAdj"&gt;
    &lt;item&gt;0&lt;/item&gt;    &lt;!-- FOREGROUND_APP --&gt;
    &lt;item&gt;100&lt;/item&gt;  &lt;!-- VISIBLE_APP --&gt;
    &lt;item&gt;200&lt;/item&gt;  &lt;!-- PERCEPTIBLE_APP --&gt;
    &lt;item&gt;250&lt;/item&gt;  &lt;!-- BACKUP_APP --&gt;
    &lt;item&gt;900&lt;/item&gt;  &lt;!-- CACHED_APP --&gt;
    &lt;item&gt;906&lt;/item&gt;  &lt;!-- EMPTY_APP --&gt;
&lt;/integer-array&gt;

&lt;!-- Protect media app priority --&gt;
&lt;string-array name="config_protectedPackages"&gt;
    &lt;item&gt;com.android.car.media&lt;/item&gt;
    &lt;item&gt;com.android.car.radio&lt;/item&gt;
&lt;/string-array&gt;</code></pre>
        </section>

        <!-- Section 8: Profiling -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">08</span>Boot Performance Measurement</h2>

            <h3>8.1 Bootchart Collection</h3>
            <pre><code># Enable Bootchart
adb shell 'echo 120 > /proc/sys/kernel/bootchart/enable'

# Collect after reboot
adb reboot

# Extract Bootchart data
adb shell 'tar -czf /data/local/tmp/bootchart.tgz /proc/bootchart'
adb pull /data/local/tmp/bootchart.tgz

# Visualize with analysis tool
bootchart bootchart.tgz</code></pre>

            <h3>8.2 Boot Time Measurement Script</h3>
            <pre><code>#!/bin/bash
# boot_time_measure.sh

echo "=== Boot Time Measurement ==="

# Reboot
adb reboot
sleep 2

# Wait for boot completion and measure time
START=$(date +%s%3N)

while true; do
    BOOT_COMPLETED=$(adb shell getprop sys.boot_completed 2>/dev/null)
    if [ "$BOOT_COMPLETED" = "1" ]; then
        END=$(date +%s%3N)
        BOOT_TIME=$((END - START))
        echo "Boot completed in: ${BOOT_TIME}ms"
        break
    fi
    sleep 0.1
done

# Media service start time
MEDIA_TIME=$(adb shell dmesg | grep "CarMediaService" | head -1 | awk '{print $2}')
echo "CarMediaService started at: $MEDIA_TIME"

# First audio output time
AUDIO_TIME=$(adb shell dmesg | grep "first audio" | head -1 | awk '{print $2}')
echo "First audio at: $AUDIO_TIME"</code></pre>

            <h3>8.3 Perfetto Boot Trace</h3>
            <pre><code># Collect Perfetto trace during boot
adb shell setprop persist.debug.perfetto.boottrace 1
adb reboot

# Extract trace
adb pull /data/misc/perfetto-traces/boottrace.perfetto-trace

# Analyze at ui.perfetto.dev</code></pre>
        </section>

        <!-- Section 9: Troubleshooting -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">09</span>Boot Performance Troubleshooting</h2>

            <h3>9.1 Common Boot Delay Causes</h3>
            <table>
                <thead>
                    <tr>
                        <th>Symptom</th>
                        <th>Cause</th>
                        <th>Diagnosis</th>
                        <th>Solution</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Audio output > 5 seconds</strong></td>
                        <td>AudioFlinger waiting for Audio HAL loading</td>
                        <td><code>logcat -b events | grep boot_progress</code></td>
                        <td>Move Audio HAL to class core, configure preload</td>
                    </tr>
                    <tr>
                        <td><strong>Slow codec initialization</strong></td>
                        <td>Codec2 component store full enumeration</td>
                        <td><code>logcat | grep C2Store</code></td>
                        <td>Component caching, remove unnecessary codecs</td>
                    </tr>
                    <tr>
                        <td><strong>CarMediaService delay</strong></td>
                        <td>LMS restore media app binding timeout</td>
                        <td><code>dumpsys car_service</code></td>
                        <td>Optimize media app startup, adjust timeout</td>
                    </tr>
                    <tr>
                        <td><strong>Silent after resume</strong></td>
                        <td>Audio HAL requires reinit on resume</td>
                        <td><code>dumpsys audio</code></td>
                        <td><code>persist.audio.keep_hal_active_on_suspend=true</code></td>
                    </tr>
                    <tr>
                        <td><strong>OOM during boot</strong></td>
                        <td>Too many services starting simultaneously</td>
                        <td><code>dmesg | grep lowmemorykiller</code></td>
                        <td>Adjust service start order, expand deferred services</td>
                    </tr>
                </tbody>
            </table>

            <h3>9.2 Boot Time Diagnostic Commands</h3>
            <pre><code># Check boot event timeline
adb shell logcat -b events -d | grep boot_progress
# Example output:
# boot_progress_start              :  5000ms  (kernel start)
# boot_progress_preload_start      : 10000ms  (preload start)
# boot_progress_preload_end        : 13000ms  (preload end)
# boot_progress_system_run         : 14000ms  (System Server start)
# boot_progress_pms_start          : 15000ms  (PackageManager start)
# boot_progress_ams_ready          : 18000ms  (ActivityManager ready)
# boot_progress_enable_screen      : 20000ms  (screen enabled)

# Check start time for each service
adb shell logcat -d | grep -E "ServiceManager: addService|Starting service"

# Measure AudioFlinger initialization time
adb shell logcat -d | grep -E "AudioFlinger|AudioPolicyService" | head -20

# Measure Codec2 HAL initialization time
adb shell logcat -d | grep -E "C2Store|codec2|CCodec" | head -20

# Measure CarService boot time
adb shell logcat -d | grep -E "CarService|CarAudioService|CarMediaService" | head -20

# init service start order and duration
adb shell dmesg | grep "init: starting service"</code></pre>

            <h3>9.3 Systrace-based Boot Analysis</h3>
            <pre><code># Collect Systrace during boot (Perfetto recommended for Android 12+)
python3 $ANDROID_HOME/platform-tools/systrace/systrace.py \
    -b 65536 -t 30 \
    am ss audio hal sched freq idle \
    -o boot_trace.html

# Boot analysis with Perfetto (recommended)
cat &lt;&lt;EOF &gt; /tmp/boot_trace_config.pbtxt
buffers {
    size_kb: 65536
    fill_policy: RING_BUFFER
}
data_sources {
    config {
        name: "linux.ftrace"
        ftrace_config {
            ftrace_events: "sched/sched_switch"
            ftrace_events: "power/cpu_frequency"
            ftrace_events: "power/suspend_resume"
            atrace_categories: "am"
            atrace_categories: "audio"
            atrace_categories: "hal"
            atrace_apps: "com.android.car"
        }
    }
}
duration_ms: 30000
EOF

adb push /tmp/boot_trace_config.pbtxt /data/local/tmp/
adb shell setprop persist.debug.perfetto.boottrace 1
adb reboot

# Collect trace after boot
adb pull /data/misc/perfetto-traces/boottrace.perfetto-trace
# Analyze at ui.perfetto.dev</code></pre>
        </section>

        <!-- Section 10: Checklist -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">10</span>Optimization Checklist</h2>

            <h3>Boot Time</h3>
            <ul class="checklist">
                <li><input type="checkbox"> Cold Boot &rarr; Audio &lt; 3s</li>
                <li><input type="checkbox"> Cold Boot &rarr; UI &lt; 5s</li>
                <li><input type="checkbox"> Early Audio working</li>
                <li><input type="checkbox"> Unnecessary services deferred (deferred services)</li>
                <li><input type="checkbox"> Critical Path services set to class core</li>
            </ul>

            <h3>Codec2 & Media Services</h3>
            <ul class="checklist">
                <li><input type="checkbox"> Codec2 component store caching applied</li>
                <li><input type="checkbox"> media_codecs.xml rank optimized (audio codecs first)</li>
                <li><input type="checkbox"> init.rc parallel media service start configured</li>
                <li><input type="checkbox"> AudioFlinger &rarr; AudioPolicy sequential dependency verified</li>
                <li><input type="checkbox"> Unnecessary video codecs disabled or lazy loaded</li>
            </ul>

            <h3>Resume Performance</h3>
            <ul class="checklist">
                <li><input type="checkbox"> Resume &rarr; Operation &lt; 1s</li>
                <li><input type="checkbox"> Resume &rarr; Audio &lt; 500ms</li>
                <li><input type="checkbox"> Media state restored correctly</li>
                <li><input type="checkbox"> Volume/position restored</li>
                <li><input type="checkbox"> Audio HAL state retention during suspend configured</li>
            </ul>

            <h3>Memory</h3>
            <ul class="checklist">
                <li><input type="checkbox"> Media app memory &lt; 128MB</li>
                <li><input type="checkbox"> onTrimMemory handling implemented</li>
                <li><input type="checkbox"> Cache policy optimized</li>
                <li><input type="checkbox"> Memory leak testing done</li>
            </ul>

            <h3>Measurement & Diagnostics</h3>
            <ul class="checklist">
                <li><input type="checkbox"> Bootchart analysis complete</li>
                <li><input type="checkbox"> Perfetto boot trace verified</li>
                <li><input type="checkbox"> Automated testing set up</li>
                <li><input type="checkbox"> boot_progress event log analyzed</li>
                <li><input type="checkbox"> Per-service initialization time baseline recorded</li>
            </ul>
        </section>

        <!-- Related Documents -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">11</span>Related Documents</h2>
            <ul>
                <li><a href="power-policy-suspend.html">Power Policy & Suspend</a> - Suspend/Resume details</li>
                <li><a href="performance-optimization.html">Performance Optimization</a> - General performance optimization</li>
                <li><a href="aaos-last-media.html">Last Media & Autoplay</a> - Media state restoration</li>
                <li><a href="vehicle-hal-media.html">Vehicle HAL Media Integration</a> - Vehicle integration</li>
            </ul>
        </section>
    </div>

    <script src="../scripts/mermaid-theme.js"></script>
    <script src="../scripts/copy-code.js"></script>
    <script src="../scripts/toc-generator.js"></script>
    <script src="../scripts/page-navigation.js"></script>
    <script src="../scripts/diagram-data.js"></script>
    <script src="../scripts/diagram-data-en-partial.js"></script>
    <script src="../scripts/diagram-interactive.js"></script>
    <script src="../scripts/theme-toggle.js?v=2"></script>
    <script src="../scripts/lang-switch.js"></script>
</body>
</html>
