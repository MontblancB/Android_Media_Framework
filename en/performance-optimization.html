<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Performance Optimization Guide - Android Media Framework</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Archivo:wght@300;400;600;700;900&family=IBM+Plex+Mono:wght@400;500;600&family=Playfair+Display:wght@700;900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../styles/design-system.css">
</head>

<body>
    <nav class="nav">
        <a href="index.html" class="nav-button">
            ← Android Media Framework
        </a>
    </nav>
    <div class="container">
        <header>
            <h1 class="page-title">Performance Optimization Guide</h1>
            <p class="page-subtitle">Practical guide for optimizing media playback performance</p>
        </header>

        <!-- Section 1: Overview -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">01</span>Overview</h2>

            <p>Media performance optimization is <strong>the core of user experience</strong>. Buffering-free playback, low latency, and battery efficiency determine the quality of media apps. This guide covers how to analyze and optimize performance at each stage of the Android media pipeline.</p>

            <h3>1.1 Performance Bottleneck Points</h3>
            <div class="mermaid">
flowchart LR
    subgraph APP["App Layer"]
        A1[Player API]
        A2[UI Rendering]
    end

    subgraph FW["Framework"]
        F1[MediaCodec]
        F2[AudioTrack]
    end

    subgraph NATIVE["Native"]
        N1[NuPlayer]
        N2[Codec2]
        N3[AudioFlinger]
    end

    subgraph HAL["HAL"]
        H1[Codec HAL]
        H2[Audio HAL]
    end

    subgraph HW["Hardware"]
        HW1[Video DSP]
        HW2[Audio DSP]
    end

    A1 --> F1
    A2 -.->|UI Bottleneck| A1
    F1 --> N1
    F1 --> N2
    F2 --> N3
    N2 --> H1
    N3 --> H2
    H1 --> HW1
    H2 --> HW2

            </div>
            <p class="diagram-caption">Red: Common bottleneck points (UI rendering, codec processing, HAL communication)</p>

            <h3>1.2 Key Performance Indicators (KPI)</h3>
            <table>
                <thead>
                    <tr>
                        <th>Metric</th>
                        <th>Target Value</th>
                        <th>Measurement Method</th>
                        <th>Impact</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>Start Latency</strong></td>
                        <td>&lt; 500ms</td>
                        <td>prepare() ~ first frame</td>
                        <td>UX perceived quality</td>
                    </tr>
                    <tr>
                        <td><strong>Frame Drop Rate</strong></td>
                        <td>&lt; 0.1%</td>
                        <td>MediaCodec.getMetrics()</td>
                        <td>Video smoothness</td>
                    </tr>
                    <tr>
                        <td><strong>A/V Sync Error</strong></td>
                        <td>±40ms</td>
                        <td>perfetto trace</td>
                        <td>Lip-sync quality</td>
                    </tr>
                    <tr>
                        <td><strong>Memory Usage</strong></td>
                        <td>&lt; 150MB</td>
                        <td>dumpsys meminfo</td>
                        <td>Background survival</td>
                    </tr>
                    <tr>
                        <td><strong>CPU Usage</strong></td>
                        <td>&lt; 15%</td>
                        <td>top / perfetto</td>
                        <td>Battery efficiency</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <!-- Section 2: Bottleneck Identification -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">02</span>Bottleneck Identification</h2>

            <p>Before optimization, it's important to <strong>identify the exact bottleneck</strong>. Guess-based optimization is a waste of time.</p>

            <h3>2.1 Perfetto Trace Collection</h3>
            <pre><code># Collect media-related traces (30 seconds)
adb shell perfetto \
  -c - --txt \
  -o /data/misc/perfetto-traces/media_trace.perfetto-trace \
&lt;&lt;EOF
buffers: {
    size_kb: 63488
    fill_policy: DISCARD
}
data_sources: {
    config {
        name: "linux.ftrace"
        ftrace_config {
            ftrace_events: "sched/sched_switch"
            ftrace_events: "power/suspend_resume"
            ftrace_events: "binder/*"
        }
    }
}
data_sources: {
    config {
        name: "android.surfaceflinger.frametimeline"
    }
}
data_sources: {
    config {
        name: "track_event"
        track_event_config {
            enabled_categories: "media"
            enabled_categories: "audio"
        }
    }
}
duration_ms: 30000
EOF

# Pull trace file
adb pull /data/misc/perfetto-traces/media_trace.perfetto-trace</code></pre>

            <h3>2.2 Analysis Workflow</h3>
            <div class="mermaid">
flowchart TD
    A[Performance issue occurs] --> B[Collect Perfetto trace]
    B --> C{Which layer?}

    C -->|App Layer| D[Android Studio Profiler]
    C -->|Framework| E[dumpsys media.codec]
    C -->|Native| F[Perfetto UI analysis]
    C -->|HAL/HW| G[Check vendor logs]

    D --> H[UI Thread blocking?]
    E --> I[Buffer underrun?]
    F --> J[CPU/GPU bound?]
    G --> K[HW decoder status?]

    H --> L[Switch to async processing]
    I --> M[Adjust buffer size]
    J --> N[Change resolution/codec]
    K --> O[Optimize HAL settings]

    L --> P[Re-measure]
    M --> P
    N --> P
    O --> P
            </div>

            <h3>2.3 dumpsys Commands</h3>
            <pre><code># Check MediaCodec status
adb shell dumpsys media.codec

# Key items to check:
# - Input/Output buffer queue status
# - Number of frames being processed
# - Error counter

# Check AudioFlinger status
adb shell dumpsys media.audio_flinger

# MediaSession status
adb shell dumpsys media_session</code></pre>

            <div class="info-box">
                <strong>Perfetto UI Tip</strong>
                <p>Open the trace at <a href="https://ui.perfetto.dev" target="_blank">ui.perfetto.dev</a> and search for <code>media</code> to filter only media-related events.</p>
            </div>
        </section>

        <!-- Section 3: Codec Optimization -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">03</span>Codec Optimization</h2>

            <h3>3.1 HW vs SW Codec Selection</h3>
            <table>
                <thead>
                    <tr>
                        <th>Criteria</th>
                        <th>HW Codec</th>
                        <th>SW Codec</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>CPU Usage</strong></td>
                        <td>Low (under 5%)</td>
                        <td>High (20~50%)</td>
                    </tr>
                    <tr>
                        <td><strong>Power Consumption</strong></td>
                        <td>Low</td>
                        <td>High</td>
                    </tr>
                    <tr>
                        <td><strong>Latency</strong></td>
                        <td>Somewhat higher</td>
                        <td>Low (immediate processing)</td>
                    </tr>
                    <tr>
                        <td><strong>Resolution Support</strong></td>
                        <td>Limited (HW dependent)</td>
                        <td>Flexible</td>
                    </tr>
                    <tr>
                        <td><strong>Recommended Use</strong></td>
                        <td>General playback, 4K/HDR</td>
                        <td>Low latency needs, special formats</td>
                    </tr>
                </tbody>
            </table>

            <h3>3.2 Codec Selection Code</h3>
            <pre><code>// Prefer HW codec selection
fun selectCodec(mimeType: String, preferHw: Boolean = true): MediaCodecInfo? {
    val codecList = MediaCodecList(MediaCodecList.REGULAR_CODECS)

    return codecList.codecInfos
        .filter { !it.isEncoder }
        .filter { it.supportedTypes.contains(mimeType) }
        .sortedByDescending { codecInfo ->
            when {
                preferHw && codecInfo.isHardwareAccelerated -> 2
                !preferHw && codecInfo.isSoftwareOnly -> 2
                else -> 1
            }
        }
        .firstOrNull()
}

// Usage example
val hwDecoder = selectCodec("video/avc", preferHw = true)
val swDecoder = selectCodec("video/avc", preferHw = false)</code></pre>

            <h3>3.3 Recommended Settings by Resolution</h3>
            <table>
                <thead>
                    <tr>
                        <th>Resolution</th>
                        <th>Codec</th>
                        <th>Bitrate</th>
                        <th>Input Buffer</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>480p</td>
                        <td>H.264 (HW/SW)</td>
                        <td>1~2 Mbps</td>
                        <td>4</td>
                    </tr>
                    <tr>
                        <td>720p</td>
                        <td>H.264/HEVC (HW)</td>
                        <td>3~5 Mbps</td>
                        <td>4</td>
                    </tr>
                    <tr>
                        <td>1080p</td>
                        <td>HEVC (HW)</td>
                        <td>5~10 Mbps</td>
                        <td>6</td>
                    </tr>
                    <tr>
                        <td>4K</td>
                        <td>HEVC/AV1 (HW)</td>
                        <td>15~25 Mbps</td>
                        <td>8</td>
                    </tr>
                    <tr>
                        <td>4K HDR</td>
                        <td>HEVC/AV1 (HW)</td>
                        <td>20~40 Mbps</td>
                        <td>8</td>
                    </tr>
                </tbody>
            </table>
        </section>

        <!-- Section 4: Buffer Management -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">04</span>Buffer Management Optimization</h2>

            <h3>4.1 Buffer Pipeline</h3>
            <div class="mermaid">
flowchart LR
    subgraph SOURCE["Data Source"]
        S1[Network/File]
    end

    subgraph DEMUX["Demuxer"]
        D1[Extractor Buffer]
    end

    subgraph CODEC["Codec"]
        C1[Input Queue]
        C2[Decoder]
        C3[Output Queue]
    end

    subgraph RENDER["Renderer"]
        R1[Surface Buffer]
        R2[Display]
    end

    S1 -->|Read| D1
    D1 -->|ES Data| C1
    C1 --> C2
    C2 --> C3
    C3 -->|Decoded Frame| R1
    R1 --> R2

            </div>

            <h3>4.2 Buffer Size Tuning</h3>
            <pre><code>// MediaCodec buffer settings
val format = MediaFormat.createVideoFormat("video/avc", width, height).apply {
    // Input buffer count (default: 4)
    setInteger(MediaFormat.KEY_MAX_INPUT_SIZE, maxInputSize)

    // Low latency mode (minimize buffers)
    setInteger(MediaFormat.KEY_LOW_LATENCY, 1)

    // Operating rate (HW optimization hint)
    setFloat(MediaFormat.KEY_OPERATING_RATE, frameRate * 1.5f)

    // Priority (real-time priority)
    setInteger(MediaFormat.KEY_PRIORITY, 0) // 0 = real-time
}

// ExoPlayer buffer settings
val loadControl = DefaultLoadControl.Builder()
    .setBufferDurationsMs(
        15_000,  // minBufferMs: minimum buffer
        50_000,  // maxBufferMs: maximum buffer
        1_500,   // bufferForPlaybackMs: buffer to start playback
        3_000    // bufferForPlaybackAfterRebufferMs: after rebuffer
    )
    .setTargetBufferBytes(C.LENGTH_UNSET)
    .setPrioritizeTimeOverSizeThresholds(true)
    .build()</code></pre>

            <h3>4.3 Preventing Buffer Underrun</h3>
            <div class="info-box warning">
                <strong>Buffer Underrun Symptoms</strong>
                <ul>
                    <li>Video stuttering</li>
                    <li>Audio pop/click noise</li>
                    <li>A/V sync breakdown</li>
                </ul>
            </div>

            <pre><code># Monitor buffer status
adb shell dumpsys media.codec | grep -A 20 "Buffer"

# Output example:
# Input buffers: 4 total, 2 queued, 2 available
# Output buffers: 8 total, 3 queued, 5 available
# Frames decoded: 1847
# Frames dropped: 0</code></pre>
        </section>

        <!-- Section 5: Memory Optimization -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">05</span>Memory Optimization</h2>

            <h3>5.1 Memory Allocation Structure</h3>
            <div class="mermaid">
flowchart TB
    subgraph APP["App Process"]
        A1[Java Heap]
        A2[Native Heap]
    end

    subgraph SYSTEM["System"]
        S1[ION/DMA-BUF]
        S2[GPU Memory]
    end

    subgraph HW["Hardware"]
        H1[Decoder Memory]
        H2[Display Buffer]
    end

    A1 -->|ByteBuffer| A2
    A2 -->|mmap| S1
    S1 -->|Zero-copy| H1
    H1 -->|Direct Render| H2
    S1 -->|Texture Upload| S2
    S2 --> H2

            </div>

            <h3>5.2 Zero-copy Pipeline</h3>
            <pre><code>// Surface-based Zero-copy (recommended)
val surface = surfaceView.holder.surface
mediaCodec.configure(format, surface, null, 0)

// Output buffer renders directly to Surface
// No CPU memory copy!

// ByteBuffer-based (copy occurs - avoid this)
val outputBuffer = mediaCodec.getOutputBuffer(outputBufferId)
// outputBuffer.get(byteArray) // Unnecessary copy!</code></pre>

            <h3>5.3 Preventing Memory Leaks</h3>
            <pre><code>// Proper resource release
class MediaPlayerManager : LifecycleObserver {
    private var mediaCodec: MediaCodec? = null
    private var surface: Surface? = null

    @OnLifecycleEvent(Lifecycle.Event.ON_DESTROY)
    fun release() {
        mediaCodec?.apply {
            stop()
            release()
        }
        mediaCodec = null

        surface?.release()
        surface = null
    }
}

// ExoPlayer release
override fun onDestroy() {
    super.onDestroy()
    player?.release()
    player = null
}</code></pre>

            <h3>5.4 Memory Monitoring</h3>
            <pre><code># Check process memory
adb shell dumpsys meminfo com.example.mediaplayer

# Key items:
# - Native Heap: native code allocation
# - Graphics: GPU/Surface memory
# - Private Dirty: actual physical memory usage

# Check ION buffers (root required)
adb shell cat /sys/kernel/debug/ion/heaps/system</code></pre>
        </section>

        <!-- Section 6: Battery Efficiency -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">06</span>Battery Efficiency Optimization</h2>

            <h3>6.1 Power Consumption Factors</h3>
            <table>
                <thead>
                    <tr>
                        <th>Factor</th>
                        <th>Impact</th>
                        <th>Optimization Method</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>CPU Usage</strong></td>
                        <td>High</td>
                        <td>Use HW codec, remove unnecessary processing</td>
                    </tr>
                    <tr>
                        <td><strong>Screen Brightness</strong></td>
                        <td>Very High</td>
                        <td>HDR tone mapping, adaptive brightness</td>
                    </tr>
                    <tr>
                        <td><strong>Network</strong></td>
                        <td>Medium</td>
                        <td>Adaptive bitrate, prefetching</td>
                    </tr>
                    <tr>
                        <td><strong>Wake Lock</strong></td>
                        <td>Medium</td>
                        <td>Minimum scope, timely release</td>
                    </tr>
                    <tr>
                        <td><strong>Background Processing</strong></td>
                        <td>Medium</td>
                        <td>JobScheduler, WorkManager</td>
                    </tr>
                </tbody>
            </table>

            <h3>6.2 Wake Lock Management</h3>
            <pre><code>// Proper Wake Lock usage
class MediaPlaybackService : Service() {
    private var wakeLock: PowerManager.WakeLock? = null

    private fun acquireWakeLock() {
        val pm = getSystemService(Context.POWER_SERVICE) as PowerManager
        wakeLock = pm.newWakeLock(
            PowerManager.PARTIAL_WAKE_LOCK,
            "MyApp::MediaPlayback"
        ).apply {
            // Timeout setting (safety measure)
            acquire(30 * 60 * 1000L) // Max 30 minutes
        }
    }

    private fun releaseWakeLock() {
        wakeLock?.let {
            if (it.isHeld) {
                it.release()
            }
        }
        wakeLock = null
    }

    override fun onDestroy() {
        releaseWakeLock()
        super.onDestroy()
    }
}</code></pre>

            <h3>6.3 Background Audio Optimization</h3>
            <pre><code>// Disable video track (audio-only playback)
player.trackSelectionParameters = player.trackSelectionParameters
    .buildUpon()
    .setTrackTypeDisabled(C.TRACK_TYPE_VIDEO, true)
    .build()

// Stop video decoding when screen off
override fun onStop() {
    super.onStop()
    if (!isChangingConfigurations) {
        player.setVideoSurface(null)
    }
}</code></pre>

            <h3>6.4 Battery Usage Measurement</h3>
            <pre><code># Battery Historian data collection
adb shell dumpsys batterystats --reset
# (use app)
adb shell dumpsys batterystats > batterystats.txt
adb bugreport > bugreport.zip

# Check power profile
adb shell dumpsys power | grep -A 20 "Power Profile"</code></pre>
        </section>

        <!-- Section 7: Case Studies -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">07</span>Practical Case Studies</h2>

            <h3>Case 1: Frame Drop During 4K Playback</h3>
            <div class="case-study">
                <h4>Symptoms</h4>
                <p>Periodic frame drops during 4K 60fps content playback</p>

                <h4>Analysis</h4>
                <pre><code># Perfetto analysis results
# - Delay in HW decoder output → Surface rendering section
# - GPU composition bottleneck</code></pre>

                <h4>Solution</h4>
                <ol>
                    <li>Changed SurfaceView → TextureView (layer separation)</li>
                    <li>Increased Operating Rate to 90fps</li>
                    <li>Minimized UI overlays</li>
                </ol>

                <h4>Result</h4>
                <p>Frame drop rate improved from 2.3% → 0.05%</p>
            </div>

            <h3>Case 2: Start Latency 1.5s → 300ms</h3>
            <div class="case-study">
                <h4>Symptoms</h4>
                <p>1.5 seconds from play button click to first frame</p>

                <h4>Analysis</h4>
                <pre><code># Latency analysis
# - prepare(): 800ms (network buffering)
# - configure(): 200ms (codec initialization)
# - First frame decoding: 500ms</code></pre>

                <h4>Solution</h4>
                <ol>
                    <li>Pre-call prepareAsync() (predict user intent)</li>
                    <li>Codec instance pooling (reuse)</li>
                    <li>bufferForPlaybackMs 1500ms → 500ms</li>
                </ol>

                <h4>Result</h4>
                <p>Perceived start time 1.5s → 300ms</p>
            </div>

            <h3>Case 3: Background Memory Increase</h3>
            <div class="case-study">
                <h4>Symptoms</h4>
                <p>Memory continuously increasing during background audio playback (leak)</p>

                <h4>Analysis</h4>
                <pre><code># LeakCanary analysis results
# - SurfaceTexture not released
# - Activity reference in MediaCodec listener</code></pre>

                <h4>Solution</h4>
                <ol>
                    <li>Explicitly release Surface when going to background</li>
                    <li>Use WeakReference in callbacks</li>
                    <li>Added onTrimMemory() handling</li>
                </ol>

                <h4>Result</h4>
                <p>Memory after 1 hour playback: 180MB → 85MB (stable)</p>
            </div>
        </section>

        <!-- Section 8: Checklist -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">08</span>Optimization Checklist</h2>

            <h3>Playback Start Optimization</h3>
            <ul class="checklist">
                <li><input type="checkbox"> Pre-call prepareAsync()</li>
                <li><input type="checkbox"> Codec instance reuse</li>
                <li><input type="checkbox"> Minimize bufferForPlaybackMs</li>
                <li><input type="checkbox"> Network prefetching</li>
            </ul>

            <h3>Playback Quality Optimization</h3>
            <ul class="checklist">
                <li><input type="checkbox"> Prefer HW codec</li>
                <li><input type="checkbox"> Select appropriate resolution/bitrate</li>
                <li><input type="checkbox"> Set Operating Rate</li>
                <li><input type="checkbox"> Tune buffer size</li>
            </ul>

            <h3>Memory Optimization</h3>
            <ul class="checklist">
                <li><input type="checkbox"> Use Surface-based Zero-copy</li>
                <li><input type="checkbox"> Explicit resource release</li>
                <li><input type="checkbox"> Disable video in background</li>
                <li><input type="checkbox"> Memory leak testing</li>
            </ul>

            <h3>Battery Optimization</h3>
            <ul class="checklist">
                <li><input type="checkbox"> Use minimum Wake Lock scope</li>
                <li><input type="checkbox"> Set timeout</li>
                <li><input type="checkbox"> Optimize background processing</li>
                <li><input type="checkbox"> Utilize adaptive bitrate</li>
            </ul>
        </section>

        <!-- Related Documents -->
        <section class="content-section section">
            <h2 class="section-title"><span class="section-number">09</span>Related Documents</h2>
            <ul>
                <li><a href="debugging-tools.html">Debugging & Profiling Tools</a> - Detailed debugging tools guide</li>
                <li><a href="codec2.html">Codec 2.0 & Media HAL</a> - Codec architecture</li>
                <li><a href="media-playback.html">Media Pipeline & Data Flow</a> - Media pipeline</li>
                <li><a href="common-media-issues.html">Common Media Issues</a> - Performance-related issue resolution</li>
            </ul>
        </section>
    </div>

    <script src="../scripts/mermaid-theme.js"></script>
    <script src="../scripts/copy-code.js"></script>
    <script src="../scripts/toc-generator.js"></script>
    <script src="../scripts/page-navigation.js"></script>
    <script src="../scripts/diagram-data.js"></script>
    <script src="../scripts/diagram-data-en-partial.js"></script>
    <script src="../scripts/diagram-interactive.js"></script>
    <script src="../scripts/theme-toggle.js"></script>
    <script src="../scripts/lang-switch.js"></script>
</body>

</html>
